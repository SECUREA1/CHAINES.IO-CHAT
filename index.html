<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>CHAINeS Chat</title>
  <link rel="icon" href="/static/logo.svg" type="image/svg+xml" />
  <link rel="apple-touch-icon" href="/static/logo.svg" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <meta name="color-scheme" content="dark light" />
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
      :root {
        --bg: #0f172a;
        --panel: #1e293b;
        --muted: #94a3b8;
        --fg: #f1f5f9;
        --accent: #00c6ff;
        --accent-2: #0072ff;
        --danger: #ef4444;
        --shadow: 0 0 12px rgba(0,114,255,.35);
        --radius: 16px;
        --lining: #334155;
        --caption-font: 'Poppins', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        --caption-color: #ffffff;
        --caption-bg: rgba(0,0,0,0.6);
        --header-height: 0px;
        --footer-height: 0px;
      }
      :root[data-theme='light']{
        --bg:#2a004f;
        --panel:rgba(42,0,79,0.4);
        --fg:#ffd700;
        --muted:#c0a000;
        --accent:#ffd700;
        --accent-2:#ffd700;
        --shadow:0 0 20px rgba(255,215,0,.4);
        --lining:#ffd700;
        --caption-color:#ffd700;
      }
    * { box-sizing: border-box; }
      html, body { height: 100%; width:100%; overflow-x:hidden; }
      body {
        margin:0;
      background:
        radial-gradient(1200px 1200px at 20% -10%, color-mix(in oklab, var(--accent-2), transparent 85%), transparent 60%),
        radial-gradient(1000px 1000px at 120% 20%, color-mix(in oklab, var(--accent), transparent 88%), transparent 60%),
        var(--bg);
      color:var(--fg);
      font: 15px/1.45 'Poppins', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    body.auth-lock { overflow:hidden; }

      .wrap {
        display:flex;
        flex-direction:column;
        min-height:100vh;
        width:100%;
        max-width:100%;
        margin:0 auto;
      }

    header { display:flex; flex-direction:column; gap:8px; padding:8px 12px; position: sticky; top: 0; z-index: 5; background: color-mix(in oklab, var(--panel), transparent 25%); backdrop-filter: blur(8px); box-shadow: var(--shadow); border:1px solid var(--lining); }
    .bar { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .brand { display:flex; align-items:center; gap:10px; }
    .brand .logo { width:32px; height:32px; border-radius:8px; background: url('static/logo.svg') no-repeat center/cover; box-shadow: var(--shadow); }
    .brand h1 { font-weight: 800; letter-spacing:.4px; font-size: 16px; margin:0; }
    .top-actions { display:flex; align-items:center; gap:8px; }
    .toolbar { display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:center; padding:6px; border:1px solid var(--lining); border-radius:var(--radius); background: color-mix(in oklab, var(--panel), transparent 25%); backdrop-filter: blur(8px); box-shadow: var(--shadow); }
    .toolbar .chip { flex:0 0 auto; }
    .self-destruct { display:flex; align-items:center; gap:4px; font-size:12px; }
    .self-destruct input { accent-color: var(--accent-2); }
    .status { display:flex; align-items:center; gap:8px; width:100%; }
    .status.top, .status.user { justify-content:space-between; }
    header .chip { padding:4px 8px; }
    footer {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:14px;
      padding:18px;
      position: sticky;
      bottom:0;
      z-index:5;
      background: color-mix(in oklab, var(--panel), transparent 25%);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      border:1px solid var(--lining);
    }
    footer .status.bottom { display:flex; width:100%; align-items:center; justify-content:center; gap:8px; }
    footer .status.bottom .chip { display:flex; justify-content:center; }
    .send img { width:24px; height:24px; }
    .chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--lining);
            border-radius:12px; background: color-mix(in oklab, var(--panel), transparent 25%); box-shadow: var(--shadow); color: var(--fg); backdrop-filter: blur(8px); }
    #live-chip, #theme-toggle, #cmd-list, #ghost-btn, #logout-btn, #conn-chip, #camera-btn, #swap-btn, #post-btn, #cleanup-btn, #attention-btn { cursor:pointer; }
    #theme-toggle, #cmd-list, #ghost-btn, #logout-btn, #camera-btn, #swap-btn, #post-btn, #cleanup-btn, #attention-btn {
      width:36px;
      height:36px;
      padding:0;
      justify-content:center;
      border-radius:12px;
    }
      #conn-chip img, #theme-toggle img, #ghost-btn img, #logout-btn img, #live-chip img,
      #camera-btn img, #swap-btn img, #post-btn img, #cleanup-btn img, #attention-btn img, #cmd-list img {
        width:24px;
        height:24px;
      }
      /* layout toggle button is hidden by default and revealed when multiple videos are present */

      #camera-btn.off img { opacity:0.5; }
      #invite-cc {
        display:flex;
        padding:0;
        border-radius:12px;
        overflow:hidden;
        height:36px;
        flex:1 1 auto;
        width:100%;
      }
    #invite-cc button {
      flex:1;
      border:0;
      padding:0 10px;
      background: color-mix(in oklab, var(--panel), transparent 25%);
      color: var(--fg);
      display:flex;
      align-items:center;
      justify-content:center;
      height:100%;
      backdrop-filter: blur(8px);
    }
    #invite-cc button img {
      width:24px;
      height:24px;
    }
    #invite-cc button + button { border-left:1px solid var(--lining); }
    #profile-link { display:inline-flex; align-items:center; gap:4px; }
    #profile-link img { width:24px; height:24px; border-radius:50%; }
    #live-chip { display:inline-flex; align-items:center; gap:4px; }
    #end-btn {
      flex: 0 0 36px;
      padding: 0;
    }
    #end-btn.live {
      background: var(--danger);
      border-color: var(--danger);
      color: #fff;
      animation: live-pulse 1s infinite;
    }
    #listener-count {
      cursor: default;
      pointer-events: none;
      gap:4px;
    }
    #ghost-btn {
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      border:0;
    }
    #ghost-btn img { width:24px; height:24px; }
    #conn-chip { display:inline-flex; align-items:center; gap:4px; }
    .usr { font-weight:600; color: var(--fg); }

    #cmd-panel {
      margin-top:8px;
      background: var(--panel);
      border: 1px solid var(--lining);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }
    #cmd-panel .chip { width:36px; height:36px; padding:0; justify-content:center; }

    main { display:flex; flex-direction:column; gap:0; padding:0; flex:1; }

    .feed { list-style:none; margin:0; padding:18px; border-radius: var(--radius); background: color-mix(in oklab, var(--panel), transparent 5%); overflow-y: auto; flex:1; box-shadow: var(--shadow); backdrop-filter: blur(8px); }
    .msg { display:flex; gap:10px; margin-bottom:14px; width:100%; }
    .msg.mine { flex-direction: row-reverse; }
    .avatar { width:36px; height:36px; border-radius:10px; display:grid; place-items:center; font-weight:700; background: #222a39; color:#c2d2ea; border:1px solid var(--lining); }
    .msg.mine .avatar { background: color-mix(in oklab, var(--accent), black 70%); color: var(--accent-2); }

    .bubble { flex:1; position:relative; padding:10px 14px 10px; border-radius: 16px; background: color-mix(in oklab, var(--panel), transparent 10%); border:1px solid var(--lining); box-shadow: var(--shadow); backdrop-filter: blur(8px); }
    .msg.mine .bubble { background: color-mix(in oklab, var(--accent), var(--bg) 75%); border-color: var(--lining); }

    .meta { display:flex; align-items:center; gap:10px; margin-bottom:4px; font-size:12px; color: var(--muted); }
    .who { font-weight:700; color: var(--fg); }

    .msg.mine .meta { justify-content:flex-end; }
    .msg.mine .msg-text { text-align:right; }

    .msg-text { white-space: pre-wrap; word-wrap: break-word; }

    video::cue {
      font-family: var(--caption-font);
      color: var(--caption-color);
      background-color: var(--caption-bg);
    }

    .actions { margin-top:6px; display:flex; gap:10px; }
    .like-btn { background:transparent; border:0; cursor:pointer; color:var(--fg); }
    .comments { margin-top:6px; }
    .comments-list { margin-bottom:6px; }
    .comment { font-size:13px; margin-bottom:4px; }
    .comment-form input { width:100%; padding:4px; border-radius:8px; border:1px solid var(--lining); background: var(--panel); color: var(--fg); }

    .msg.collapsed .msg-text { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; max-height: 3.3em; }
    .min-btn { position:absolute; top:8px; right:8px; border:0; background:transparent; color:var(--muted); cursor:pointer; font-size:16px; padding:2px 6px; border-radius:8px; }
    .min-btn:hover { color:var(--fg); background: rgba(255,255,255,.06); }

    .system { text-align:center; color: var(--muted); font-size: 13px; margin: 12px 0; }

    .composer { display:grid; grid-template-columns: minmax(0,1fr) 56px; gap:10px; margin:0; width:100%; }
    #composer { grid-template-columns: minmax(0,1fr) repeat(2,56px); }
    .input { display:flex; align-items:center; gap:10px; padding:10px 12px; border-radius: 12px; background: color-mix(in oklab, var(--panel), transparent 25%); border:2px solid var(--accent); box-shadow: var(--shadow); backdrop-filter: blur(8px); }
    .input input { flex:1; font: inherit; color: var(--fg); background: transparent; border:0; outline:0; }
    .input input::placeholder { color: color-mix(in oklab, var(--muted), transparent 10%); }
    .send { display:flex; align-items:center; justify-content:center; width:56px; height:56px; font-size:24px; border-radius:12px; border:2px solid var(--accent-2); font-weight:700; cursor:pointer; color:#05130e; background: linear-gradient(180deg, var(--accent), var(--accent-2)); box-shadow: var(--shadow); }
    .send:disabled { opacity:.6; cursor:not-allowed; }

    /* Auth screen */
    .auth { position: fixed; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.65)); backdrop-filter: blur(4px); overflow:auto; }
    .card { width:min(520px, 92vw); padding:22px; border-radius: 18px; background: color-mix(in oklab, var(--panel), transparent 25%); border: 1px solid var(--lining); box-shadow: var(--shadow); backdrop-filter: blur(8px); }
    .card h2 { margin:0 0 8px; font-size: 22px; }
    .card p { margin: 0 0 14px; color: var(--muted); }
    .fields { display:grid; gap:10px; }
    .fields input { width:100%; padding:12px 14px; border-radius:12px; border:1px solid var(--lining); background: var(--panel); color: var(--fg); font: inherit; font-size:16px; }
    .actions { display:flex; gap:10px; margin-top:12px; }
    .btn { padding:12px 14px; border-radius:12px; border:0; font-weight:700; cursor:pointer; }
    .btn.primary { background: linear-gradient(180deg, var(--accent), var(--accent-2)); color:#05130e; }
    .btn.ghost { background: color-mix(in oklab, var(--panel), transparent 10%); color: var(--fg); border:1px solid var(--lining); }

    .muted-link { color: var(--muted); text-decoration: underline; cursor: pointer; }

    footer { padding: 0 18px 16px; color: var(--muted); text-align:center; font-size: 12px; }
    a { color: var(--accent-2); }

    .users-panel { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); padding:14px; border-radius:var(--radius); background:var(--panel); border:1px solid var(--lining); box-shadow:var(--shadow); max-width:200px; max-height:60vh; overflow-y:auto; }
    .users-panel h3 { margin:0 0 8px; font-size:14px; }
    .users-panel ul { list-style:none; margin:0; padding:0; }
    .users-panel li { padding:4px 0; border-bottom:1px solid var(--lining); display:flex; align-items:center; gap:4px; }
    .users-panel li:last-child { border-bottom:0; }
    .users-panel li.mic-user { color:#22c55e; }
    .users-panel li button { background:transparent; border:0; cursor:pointer; padding:0 2px; }
    .users-panel li button img { width:16px; height:16px; }

    .popup { position:fixed; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); }
    .popup-content { background:var(--panel); color:var(--fg); padding:16px; border-radius:var(--radius); box-shadow:var(--shadow); min-width:200px; text-align:center; }
    .popup-actions { margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    .popup-actions button { padding:6px 12px; border-radius:var(--radius); border:1px solid var(--lining); background:var(--btn); cursor:pointer; }

    .live-btn {
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 12px;
      border:0;
      border-radius:12px;
      background:linear-gradient(180deg, var(--accent), var(--accent-2));
      cursor:pointer;
      color:#05130e;
      font-weight:700;
      box-shadow: var(--shadow);
    }
    .live-dot {
      display:inline-block;
      width:8px;
      height:8px;
      border-radius:50%;
      background:var(--danger);
      animation: live-pulse 1s infinite;
    }
    @keyframes live-pulse {
      0%, 100% { opacity:1; }
      50% { opacity:0.2; }
    }

    #broadcast-btn.live {
      background: var(--danger);
      color:#fff;
      border:0;
      animation: live-pulse 1s infinite;
    }

/* Vertical wrapper for self + remote tiles */
#stream-tiles {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

/* Horizontal scrollers for streams */
#streams,
#remote-tiles {
  display: flex;
  flex-wrap: nowrap;
  gap: 10px;
  padding: 10px;
  overflow-x: auto;
  width: 100%;
}

/* Self tile row */
#self-tile {
  display: flex;
  justify-content: center;
  width: 100%;
}

/* Stream cards */
.stream {
  position: relative;
  width: 150px;
  flex: 0 0 auto;
  border: 1px solid var(--lining);
  border-radius: 12px;
  padding: 8px;
  background: var(--panel);
  cursor: pointer;
}

/* Expanded stream state */
.stream.open {
  width: 300px;
  flex: 0 0 auto;
}

    .stream .title { font-weight:700; margin-bottom:6px; }
    .stream .thumb { width:100%; border-radius:8px; }
    .stream.open .thumb { display:none; }
    .stream .video { display:none; }
    .stream.open .video { display:block; }
    .stream .tune-btn { margin-top:6px; width:100%; }
    .stream .join-btns {
      position:absolute;
      top:8px;
      right:8px;
      display:flex;
      gap:4px;
    }
    .stream .join-btns .chip {
      width:32px;
      height:32px;
      padding:0;
    }
    .stream .video video {
      width:100%;
      border-radius:8px;
      aspect-ratio:16/9;
      object-fit:cover;
    }
    .stream.open .video.has-guest { display:flex; }
    .stream.open .video.has-guest video {
      width:50%;
      height:100%;
      max-width:50%;
      max-height:100%;
      border-radius:0;
      object-fit:contain;
    }
    @media (orientation: portrait) {
      .stream.open .video.has-guest { flex-direction:column; }
      .stream.open .video.has-guest video {
        width:100%;
        height:50%;
        max-width:100%;
        max-height:50%;
      }
    }
    .stream.open .video.pip { position:relative; display:block; }
    .stream.open .video.pip video {
      width:100%;
      height:100%;
      max-width:100%;
      max-height:100%;
      border-radius:0;
      object-fit:contain;
    }
    .stream.open .video.pip video:nth-child(2) {
      position:absolute;
      width:30%;
      height:30%;
      bottom:10px;
      right:10px;
      border:2px solid #fff;
      border-radius:8px;
      max-width:none;
      max-height:none;
    }
    .stream-feed { list-style:none; margin:8px 0 0; padding:0; max-height:120px; overflow-y:auto; display:none; }
    .stream.open .stream-feed { display:block; }
    .stream-composer { display:none; margin-top:4px; gap:4px; }
    .stream.open .stream-composer { display:flex; }
    .stream-composer input { flex:1; }
    #video-container {
      position: relative;
      width: 100%;
      max-height: calc(100vh - var(--header-height) - var(--footer-height));
      aspect-ratio: 16/9;
      margin: 0 auto;
      border: 1px solid var(--lining);
      border-radius: 12px;
      background: var(--panel);
      overflow: hidden;
    }
    #video-container video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    .video-canvas {
      position: relative;
    }
    #video-container.has-guest {
      display: flex;
      flex-direction: row;
      aspect-ratio: auto;
    }
    #video-container.has-guest #host-canvas,
    #video-container.has-guest #guest-canvas {
      width: 50%;
      height: auto;
      aspect-ratio: 16/9;
    }
    @media (orientation: portrait) {
      #video-container.has-guest {
        flex-direction: column;
      }
      #video-container.has-guest #host-canvas,
      #video-container.has-guest #guest-canvas {
        width: 100%;
        height: auto;
        aspect-ratio: 9/16;
      }
    }
    #video-container.pip {
      display: block;
    }
    #video-container.pip #host-canvas {
      width: 100%;
      height: 100%;
    }
    #video-container.pip #guest-canvas {
      position: absolute;
      width: 30%;
      height: 30%;
      bottom: 10px;
      right: 10px;
      border: 2px solid #fff;
      border-radius: 8px;
      overflow: hidden;
    }
    #video-container.pip #guest-canvas video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #join-controls {
      position: absolute;
      bottom: calc(var(--footer-height) + 8px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
    }

    #overlay-chat {
      position: fixed;
      bottom: calc(var(--footer-height) + 80px);
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 10px;
      z-index: 1002;
      pointer-events: none;
    }
    .overlay-msg {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--caption-bg);
      color: var(--caption-color);
      border-radius: 12px;
      padding: 4px 8px;
      font-weight: bold;
      box-shadow: var(--shadow);
      animation: fade-out 5s forwards;
    }
    .overlay-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--muted);
      color: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
      background-size: cover;
      background-position: center;
    }
    @keyframes fade-out {
      0%,80% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Fullscreen broadcast layout */
    body.broadcast-mode footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(4px);
      z-index: 1002;
      padding: 8px;
      gap: 0;
    }
    body.broadcast-mode footer .status.bottom {
      display: none;
    }
    .broadcast-controls {
      display: none;
      gap: 8px;
      width: 100%;
      justify-content: center;
    }
    .broadcast-controls .chip { flex:1; }
    body.broadcast-mode .broadcast-controls { display:flex; }
    body.broadcast-mode #feed {
      position: fixed;
      left: 0;
      bottom: 56px;
      width: 100%;
      height: calc(33% - 56px);
      margin: 0;
      border-radius: 0;
      background: rgba(0,0,0,0.03);
      z-index: 1001;
      overflow-y: auto;
      display: none;
      font-weight: bold;
    }
    body.broadcast-mode.chat-open #feed { display:block; }
    body.broadcast-mode #composer {
      display: none;
    }
    body.broadcast-mode #broadcast-composer {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      z-index: 1002;
      background: rgba(0,0,0,0.03);
    }
    body.broadcast-mode header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(4px);
      z-index: 1003;
    }
    body.broadcast-mode main { margin-top: var(--header-height); }
    body.broadcast-mode #user-list {
      top: calc(var(--header-height) + 8px);
      transform: translate(-50%, 0);
    }
    body.broadcast-mode header .brand { display:none; }
    body.broadcast-mode header .status.top { width:100%; justify-content:center; }
    body.broadcast-mode header .chip {
      background: rgba(0,0,0,0.6);
      border-color: rgba(255,255,255,0.2);
    }
    body.broadcast-mode #feed .bubble {
      background: rgba(0,0,0,0.6);
      border-color: rgba(255,255,255,0.2);
      color: #fff;
    }
    body.broadcast-mode #feed .meta { color: #ddd; }

    #thumb-chooser {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: color-mix(in oklab, var(--panel), transparent 20%);
      z-index: 1002;
    }
    #thumb-chooser .thumb-explain {
      margin-bottom: 16px;
      font-size: 1.2rem;
      text-align: center;
    }
    #thumb-chooser .thumb-options {
      display: flex;
      gap: 20px;
    }
    #thumb-chooser .thumb-options button {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: 2rem;
      background: var(--panel);
      border: none;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
    }
    #thumb-chooser .thumb-options .label {
      font-size: 1rem;
    }

    /* ‚úÖ make hidden actually hide, even with .auth display rules */
    [hidden] { display: none !important; }
    .auth.is-hidden { display: none !important; }
    @media (max-width: 600px) {
      header { padding:12px; gap:8px; }
      footer { padding:0 12px 12px; gap:8px; }
      .feed { padding:12px; }
      .composer { margin:0; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
                <div class="bar">
          <div class="brand">
            <div class="logo" aria-hidden="true"></div>
            <h1>CHAINeS Chat</h1>
          </div>
          <div class="top-actions">
            <label class="self-destruct" title="Auto-delete your posts after 5 minutes">
              <input type="checkbox" id="auto-delete" />
              Self-destruct in 5m
            </label>
            <button class="chip" id="camera-btn" type="button" title="Turn camera off">
              <img src="static/camera.svg" alt="Toggle camera" />
            </button>
            <button id="theme-toggle" class="chip" title="Toggle dark or light mode"><img src="static/sun.svg" alt="Toggle theme"/></button>
            <button class="chip" id="swap-btn" type="button" title="Split view" hidden>
              <img src="static/flip.svg" alt="Switch view" />
            </button>
            <button id="logout-btn" class="chip" type="button" title="Logout" aria-label="Logout"><img src="static/logout.svg" alt="Logout" /></button>
          </div>
        </div>
        <div class="toolbar">
          <button id="conn-chip" class="chip" title="Toggle connection"><img id="conn-icon" src="static/cloud.svg" alt="Connection" /><span id="conn-label">Offline</span></button>
          <span id="live-chip" class="chip" title="Users active"><img src="static/user.svg" alt="Users" /><span id="live-count">0</span></span>
          <a id="profile-link" class="chip" href="/profile.html"><img id="profile-pic" src="static/user.svg" alt="Profile" hidden><span id="profile-name">Profile</span></a>
          <button id="ghost-btn" class="chip" type="button" title="Hologhost" aria-label="Hologhost"><img src="static/hologhost.svg" alt="Hologhost" /></button>
          <button id="video-toggle" class="chip" type="button" title="Show live feed">Show Feed</button>
        </div>
        <div class="status top">
          <div class="chip" id="invite-cc">
            <button id="stream-code-btn" type="button" title="Copy stream code" aria-label="Copy stream code"><img src="static/antenna.svg" alt="Stream code" /></button>
            <button id="camera-flip-btn" type="button" title="Switch camera" aria-label="Switch camera"><img src="static/flip.svg" alt="Flip camera" /></button>
            <button id="invite-btn" type="button" title="Invite listeners" aria-label="Invite listeners"><img src="static/mail-mic.svg" alt="Invite" /></button>
            <button id="end-btn" type="button" title="End broadcast" aria-label="End broadcast"><img src="static/stop.svg" alt="End" /></button>
            <button id="listener-count" type="button" title="Active listeners" aria-label="Active listeners"><img src="static/listeners.svg" alt="Listeners" /><span id="listener-count-number">0</span></button>
          </div>
        </div>
    </header>

      <main>
        <div id="stream-tiles">
          <div id="remote-tiles" class="streams"></div>
          <div id="self-tile"></div>
        </div>
        <div id="video-container" hidden>
          <div id="host-canvas" class="video-canvas"></div>
          <div id="guest-canvas" class="video-canvas" hidden></div>
          <div id="join-controls" hidden>
            <button id="join-cam" class="chip" type="button" title="Request to join with camera"><img src="static/camera.svg" alt="Join with camera" /></button>
            <button id="join-mic" class="chip" type="button" title="Request to join with mic"><img src="static/mic.svg" alt="Request mic" /></button>
          </div>
        </div>
        <div id="overlay-chat" hidden></div>
        <ul id="feed" class="feed" aria-live="polite" aria-busy="false"></ul>
      </main>

    <footer>
      <form id="composer" class="composer" autocomplete="off">
        <label class="input" for="text">
          <input id="text" name="text" placeholder="Type a message‚Ä¶ (try /wave, /me dance or /clear)" />
        </label>
        <button class="send" id="attach" type="button" aria-label="Attach file"><img src="static/attach.svg" alt="Attach" /></button>
        <button class="send" id="send" type="submit" aria-label="Send message"><img src="static/send.svg" alt="Send" /></button>
      </form>
      <input id="file" type="file" hidden />
      <div class="broadcast-controls" id="broadcast-controls" hidden>
        <button class="chip" id="chat-toggle" type="button">üí¨ Chat</button>
        <button class="chip" id="exit-broadcast" type="button">Exit</button>
      </div>
      <form id="broadcast-composer" class="composer" autocomplete="off" hidden>
        <label class="input" for="broadcast-text">
          <input id="broadcast-text" name="broadcast-text" placeholder="Broadcast message‚Ä¶" />
        </label>
        <button class="send" id="broadcast-send" type="submit" aria-label="Send broadcast message"><img src="static/send.svg" alt="Send" /></button>
      </form>
      <div class="status bottom">
        <button class="chip live-btn" id="broadcast-btn" title="Go live">
          <span class="live-dot"></span><img src="static/camera.svg" alt="Go live" />Go Live
        </button>
        <button id="post-btn" class="chip" title="Post" aria-label="Post"><img src="static/post.svg" alt="Post" /></button>
        <button id="cleanup-btn" class="chip" title="Clean up" aria-label="Clean up"><img src="static/cleanup.svg" alt="Clean up" /></button>
        <button id="attention-btn" class="chip" title="Attention" aria-label="Attention"><img src="static/attention.svg" alt="Attention" /></button>
        <button id="cmd-list" class="chip" title="Show commands" aria-label="Show commands"><img src="static/command.svg" alt="Commands" /></button>
      </div>
    </footer>
  </div>

  <div id="user-list" class="users-panel" hidden>
    <h3>Online now</h3>
    <ul id="users"></ul>
  </div>

  <div id="popup" class="popup" hidden>
    <div class="popup-content">
      <p id="popup-text"></p>
      <div id="popup-actions" class="popup-actions"></div>
    </div>
  </div>

  <!-- Auth overlay -->
  <section id="auth" class="auth" hidden>
    <div class="card">
      <h2>Welcome to CHAINeS Chat</h2>
      <p>Create an account or log in to join the chatroom.</p>
      <div class="fields">
        <input id="username" placeholder="Username (e.g., jodel)" maxlength="24" />
        <input id="password" type="password" placeholder="Password" />
        <input id="profile" type="file" accept="image/*" />
      </div>
      <div class="actions">
        <button class="btn primary" id="login" type="button">Login</button>
        <button class="btn ghost" id="register" type="button">Register</button>
        <button class="btn ghost" id="skip" type="button">Continue as Guest</button>
      </div>
      <p style="margin-top:10px">Optional backend socket: <span class="muted-link" id="ws-edit">configure</span></p>
      <div id="ws-config" class="fields" style="display:none; margin-top:8px">
        <input id="ws-url" placeholder="wss://chaines-io-chat.onrender.com/ws (optional)" />
        <button class="btn ghost" id="save-ws" type="button">Save Socket URL</button>
      </div>
    </div>
  </section>

  <!-- Thumbnail chooser overlay -->
  <div id="thumb-chooser" hidden>
    <p class="thumb-explain">Choose a thumbnail for your broadcast</p>
    <div class="thumb-options">
      <button id="thumb-upload" title="Upload image">
        <span class="icon">üñºÔ∏è</span>
        <span class="label">Upload</span>
      </button>
      <button id="thumb-camera" title="Take photo">
        <span class="icon">üì∑</span>
        <span class="label">Snap</span>
      </button>
      <button id="thumb-skip" title="No photo">
        <span class="icon">üö´</span>
        <span class="label">Skip</span>
      </button>
    </div>
  </div>

  <script>
  ;(() => {
    const el = (q, parent=document) => parent.querySelector(q);
    const feed = el('#feed');
    const form = el('#composer');
    const input = el('#text');
    const attachBtn = el('#attach');
    const fileInput = el('#file');
    const sendBtn = el('#send');
    const cmdListBtn = el('#cmd-list');
    const autoDeleteToggle = el('#auto-delete');
    const defaultPlaceholder = input.placeholder;
    const footer = el('footer');
    const actionCommands = {
      wave:      { text: 'waves \u{1F44B}', icon: 'üëã' },
      shrug:     { text: 'shrugs \u{1F937}', icon: 'ü§∑' },
      smile:     { text: 'smiles \u{1F642}', icon: 'üòä' },
      laugh:     { text: 'laughs \u{1F602}', icon: 'üòÇ' },
      dance:     { text: 'dances \u{1F483}', icon: 'üíÉ' },
      cry:       { text: 'cries a river \u{1F622}', icon: 'üò¢' },
      sob:       { text: 'sobs like a soap opera star \u{1F62D}', icon: 'üò≠' },
      joke:      { text: 'tells a dad joke so bad it hurts \u{1F923}', icon: 'ü§™' },
      facepalm:  { text: 'facepalms in disbelief \u{1F926}', icon: 'ü§¶' },
      sing:      { text: 'sings off-key karaoke \u{1F3A4}', icon: 'üé§' },
      clap:      { text: 'claps wildly \u{1F44F}', icon: 'üëè' },
      thumbsup:  { text: 'gives a thumbs up \u{1F44D}', icon: 'üëç' },
      party:     { text: 'throws a party \u{1F389}', icon: 'üéâ' }
    };
    const cmdPanel = document.createElement('div');
    cmdPanel.id = 'cmd-panel';
    cmdPanel.hidden = true;
    footer.insertBefore(cmdPanel, footer.querySelector('#broadcast-controls'));

    function renderCmdPanel(){
      cmdPanel.innerHTML = '';
      Object.entries(actionCommands).forEach(([cmd, info]) => {
        const b = document.createElement('button');
        b.className = 'chip';
        b.type = 'button';
        b.textContent = info.icon;
        b.title = '/' + cmd;
        b.addEventListener('click', () => {
          postMessage({ text: `*${info.text}*`, isAction: true });
          cmdPanel.hidden = true;
        });
        cmdPanel.appendChild(b);
      });
    }
    renderCmdPanel();
    let pendingFile = null;
    let fileLoading = false;
    const auth = el('#auth');
    const usernameInput = el('#username');
    const passwordInput = el('#password');
    const profileInput = el('#profile');
    const loginBtn = el('#login');
    const registerBtn = el('#register');
    const skipBtn = el('#skip');
    const profileLink = el('#profile-link');
    const profilePicEl = el('#profile-pic');
    const profileNameEl = el('#profile-name');
    const logoutBtn = el('#logout-btn');
    const connChip = el('#conn-chip');
    const connIcon = el('#conn-icon');
    const connLabel = el('#conn-label');
    const liveCount = el('#live-count');
    const wsEdit = el('#ws-edit');
    const wsCfg = el('#ws-config');
    const wsUrlInput = el('#ws-url');
    const liveChip = el('#live-chip');
    const themeToggle = el('#theme-toggle');
    const themeToggleIcon = themeToggle.querySelector('img');
    const userList = el('#user-list');
    const usersEl = el('#users');
    const popup = el('#popup');
    const popupText = el('#popup-text');
    const popupActions = el('#popup-actions');
    let userCache = [];
    const broadcastBtn = el('#broadcast-btn');
    const streamCodeBtn = el('#stream-code-btn');
    const cameraFlipBtn = el('#camera-flip-btn');
    const swapBtn = el('#swap-btn');
    const inviteBtn = el('#invite-btn');
    const endBtn = el('#end-btn');
    const exitBroadcast = el('#exit-broadcast');
    const broadcastControls = el('#broadcast-controls');
    const chatToggle = el('#chat-toggle');
    const cameraBtn = el('#camera-btn');
    const broadcastComposer = el('#broadcast-composer');
    const broadcastInput = el('#broadcast-text');
    const headerBar = el('header');
    const footerBar = el('footer');
    const thumbChooser = el('#thumb-chooser');
    const thumbUpload = el('#thumb-upload');
    const thumbCamera = el('#thumb-camera');
    const thumbSkip = el('#thumb-skip');
    const listenerCountBtn = el('#listener-count');
    const listenerCountSpan = el('#listener-count-number');
    const videoContainer = el('#video-container');
    const streamTiles = el('#stream-tiles');
    const overlayChat = el('#overlay-chat');
    const streamsEl = el('#remote-tiles');
    const selfStreamEl = el('#self-tile');
    const streams = {};
    const guestMap = {};
    const pendingThumbs = {};
    const pendingWatchers = new Set();
    const videoToggle = el('#video-toggle');
    const joinControls = el('#join-controls');
    const joinCamBtn = el('#join-cam');
    const joinMicBtn = el('#join-mic');
    let currentHost = null;
    let broadcastThumb = null;
    let pendingJoinHost = null;
    let joinApproved = false;
    let pendingMicHost = null;
    let micApproved = false;
    const layoutTitles = { split: 'Split view', pip: 'Picture-in-picture' };
    const layouts = ['split', 'pip'];
    let layoutMode = 'split';
    let cameraOff = false;
    let blankTrack = null;

    // ensure header and footer remain visible
    const keepVisible = el => {
      if(!el) return;
      el.style.opacity = '1';
      el.style.visibility = 'visible';
      el.removeAttribute('hidden');
    };
    [headerBar, footerBar].forEach(el => {
      keepVisible(el);
      new MutationObserver(() => keepVisible(el)).observe(el, { attributes: true });
    });

    el('#year').textContent = new Date().getFullYear();

    chatToggle.addEventListener('click', () => {
      document.body.classList.toggle('chat-open');
    });

    if(cameraBtn){
      cameraBtn.addEventListener('click', toggleCamera);
    }
    if(cameraFlipBtn){
      cameraFlipBtn.addEventListener('click', switchCamera);
    }
    if(videoToggle){
      videoToggle.textContent = streamTiles.hasAttribute('hidden') ? 'Show Feed' : 'Hide Feed';
      videoToggle.addEventListener('click', () => {
        if(streamTiles.hasAttribute('hidden')){
          streamTiles.removeAttribute('hidden');
          videoToggle.textContent = 'Hide Feed';
        } else {
          streamTiles.setAttribute('hidden','');
          videoToggle.textContent = 'Show Feed';
        }
      });
    }
    if(joinCamBtn){
      joinCamBtn.addEventListener('click', () => {
        if(currentHost){
          pendingJoinHost = currentHost;
          joinCamBtn.disabled = true;
          sendSignal({ type: 'join-request', id: currentHost, user: store.user });
          systemNote('Join request sent');
        }
      });
    }
    if(joinMicBtn){
      joinMicBtn.addEventListener('click', () => {
        if(currentHost){
          pendingMicHost = currentHost;
          joinMicBtn.disabled = true;
          sendSignal({ type: 'mic-request', id: currentHost, user: store.user });
          systemNote('Mic request sent');
        }
      });
    }
    if(swapBtn){
      swapBtn.addEventListener('click', swapVideos);
      swapBtn.title = layoutTitles[layoutMode];
    }

    window.addEventListener('resize', () => {
      updateVideoLayout();
      for(const id in streams){
        if(streams[id] && streams[id].video){
          updateVideoLayout(streams[id].video);
        }
      }
    });

    // --- Basic state ---
    const store = {
      get user() {
        try { return localStorage.getItem('chaines_username') || ''; }
        catch { return ''; }
      },
      set user(v) {
        try { v ? localStorage.setItem('chaines_username', v) : localStorage.removeItem('chaines_username'); }
        catch {}
      },
      get profilePic() {
        try { return localStorage.getItem('chaines_profile_pic') || ''; }
        catch { return ''; }
      },
      set profilePic(v) {
        try { v ? localStorage.setItem('chaines_profile_pic', v) : localStorage.removeItem('chaines_profile_pic'); }
        catch {}
      },
      get wsURL() {
        try { return localStorage.getItem('chaines_ws_url') || defaultWS(); }
        catch { return defaultWS(); }
      },
      set wsURL(v) {
        try { v ? localStorage.setItem('chaines_ws_url', v) : localStorage.removeItem('chaines_ws_url'); }
        catch {}
      },
      get theme() {
        try { return localStorage.getItem('chaines_theme') || ''; }
        catch { return ''; }
      },
      set theme(v) {
        try { v ? localStorage.setItem('chaines_theme', v) : localStorage.removeItem('chaines_theme'); }
        catch {}
      },
      get autoDelete(){
        try { return localStorage.getItem('chaines_autodelete') === '1'; }
        catch { return false; }
      },
      set autoDelete(v){
        try { v ? localStorage.setItem('chaines_autodelete','1') : localStorage.removeItem('chaines_autodelete'); }
        catch {}
      },
      get obsRPC() {
        try { return localStorage.getItem('chaines_obs_rpc') || ''; }
        catch { return ''; }
      },
      set obsRPC(v) {
        try { v ? localStorage.setItem('chaines_obs_rpc', v) : localStorage.removeItem('chaines_obs_rpc'); }
        catch {}
      },
      get obsKey() {
        try { return localStorage.getItem('chaines_obs_key') || ''; }
        catch { return ''; }
      },
      set obsKey(v) {
        try { v ? localStorage.setItem('chaines_obs_key', v) : localStorage.removeItem('chaines_obs_key'); }
        catch {}
      },
      pushMsg(m) {
        try {
          const items = JSON.parse(localStorage.getItem('chaines_messages') || '[]');
          items.push(m); while (items.length > 200) items.shift();
          localStorage.setItem('chaines_messages', JSON.stringify(items));
        } catch {}
      },
      removeMsg(id){
        try{
          const items = JSON.parse(localStorage.getItem('chaines_messages') || '[]').filter(x => x.id !== id);
          localStorage.setItem('chaines_messages', JSON.stringify(items));
        } catch{}
      },
      loadMsgs() {
        try {
          const items = JSON.parse(localStorage.getItem('chaines_messages') || '[]');
          const now = Date.now();
          const valid = items.filter(m => !m.selfDestruct || now - m.ts < m.selfDestruct);
          localStorage.setItem('chaines_messages', JSON.stringify(valid));
          return valid;
        } catch { return []; }
      },
      clearMsgs() {
        try { localStorage.removeItem('chaines_messages'); } catch {}
      }
    };

    autoDeleteToggle.checked = store.autoDelete;
    autoDeleteToggle.addEventListener('change', () => {
      store.autoDelete = autoDeleteToggle.checked;
    });

    function applyTheme(t){
      document.documentElement.dataset.theme = t;
      themeToggleIcon.src = t === 'light' ? 'static/moon.svg' : 'static/sun.svg';
    }
    const initialTheme = store.theme || 'light';
    applyTheme(initialTheme);
    themeToggle.addEventListener('click', () => {
      const next = document.documentElement.dataset.theme === 'light' ? 'dark' : 'light';
      store.theme = next;
      applyTheme(next);
    });
    liveChip.addEventListener('click', () => { userList.hidden = !userList.hidden; });
    connChip.addEventListener('click', () => {
      if (onlineMode === 'cloud') {
        try { socket && socket.close(); } catch {}
        socket = null;
        setStatus(bc ? 'local' : 'off');
      } else {
        connectWS();
      }
    });
    broadcastBtn.addEventListener('click', async () => {
      if (broadcasting) { endBroadcast(); return; }
      const others = Object.keys(streams).filter(id => id !== clientId);
      if (others.length > 0 && !joinApproved) {
        const hostId = others[0];
        pendingJoinHost = hostId;
        sendSignal({ type: 'join-request', id: hostId, user: store.user });
        broadcastBtn.disabled = true;
        broadcastBtn.textContent = '‚è≥ Pending';
      } else {
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: usingFrontCamera ? 'user' : 'environment' },
            audio: true
          });
        } catch (err) {
          console.warn('Primary media access failed, trying default devices', err);
          try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          } catch (err2) {
            console.error('Unable to access camera/microphone', err2);
            alert('Unable to access camera/microphone. Please check browser permissions and ensure no other app is using them.');
            return;
          }
        }
        broadcastThumb = await chooseThumbnail();
        if (broadcastThumb) {
          ensureStreamThumb(clientId, store.user, true);
          handleThumbnail(clientId, broadcastThumb);
          sendSignal({ type: 'thumb', thumb: broadcastThumb });
        }
        startBroadcast(stream);
      }
    });
    streamCodeBtn.addEventListener('click', () => {
      const code = `stream-${clientId || store.user}`;
      const rpc = prompt('Enter OBS RPC URL', store.obsRPC || '');
      if (rpc !== null) store.obsRPC = rpc.trim();
      const key = prompt('Enter OBS stream key', store.obsKey || '');
      if (key !== null) store.obsKey = key.trim();

      if (store.obsKey) {
        const feedUrl = store.obsRPC
          ? `${store.obsRPC.replace(/\/?$/, '')}/${encodeURIComponent(store.obsKey)}`
          : store.obsKey;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(feedUrl)
            .then(() => alert('OBS feed URL copied'));
        } else {
          prompt('OBS feed URL:', feedUrl);
        }
      }

      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(code).then(() => alert('Stream code copied'));
      } else {
        prompt('Your stream code:', code);
      }
    });
    inviteBtn.addEventListener('click', () => {
      if(!userCache.length){ alert('No users online'); return; }
      showPopup('Invite who?', userCache.map(u => {
        const name = typeof u === 'string' ? u : u.name;
        const id = typeof u === 'string' ? u : u.id;
        return {
          label: '@' + name,
          onClick: () => {
            showPopup(`Invite @${name} to join via‚Ä¶`, [
              { label: 'Camera', onClick: () => { sendSignal({ type: 'invite', mode: 'join', target: id }); hidePopup(); } },
              { label: 'Mic', onClick: () => { sendSignal({ type: 'invite', mode: 'mic', target: id }); hidePopup(); } },
              { label: 'Cancel', onClick: () => hidePopup() }
            ]);
          }
        };
      }));
    });
    endBtn.addEventListener('click', () => { endBroadcast(); });
    exitBroadcast.addEventListener('click', () => { endBroadcast(); });
    window.addEventListener('beforeunload', () => {
      endBroadcast(true);
      for(const id in streams){
        if(streams[id].started && !streams[id].self){ endWatching(id); }
      }
    });

    // --- Connection setup (optional WebSocket + local BroadcastChannel fallback) ---
    let socket = null;
    let bc = null;
    let onlineMode = 'off'; // 'cloud' | 'local' | 'off'
    const seen = new Set();
    const seenComments = new Set();

    // --- WebRTC state ---
      const peerConnections = {};
      let localStream = null;
      let clientId = null;
      const activeRooms = new Set();
    let broadcasting = false;
    let broadcastTimer = null;
    let broadcastVideo = null;
    let captionTrack = null;
    let speechRec = null;
    let usingFrontCamera = true;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordCanvas = null;
    let recordCtx = null;
    let drawHandle = null;
    let recordMime = 'video/webm';
    let overlayMessages = [];

    function showOverlayMessage({ user, text, profilePic }){
      if(!overlayChat) return;
      const wrap = document.createElement('div');
      wrap.className = 'overlay-msg';
      const av = document.createElement('div');
      av.className = 'overlay-avatar';
      if(profilePic){
        av.style.backgroundImage = `url(${profilePic})`;
      } else {
        av.textContent = initials(user);
      }
      const span = document.createElement('div');
      span.innerHTML = `<span class="who">@${escapeHTML(user)}</span>: ${renderText(text)}`;
      wrap.appendChild(av);
      wrap.appendChild(span);
      overlayChat.appendChild(wrap);
      setTimeout(() => wrap.remove(), 5000);
    }

      function updateHeaderButtons(){
        [streamCodeBtn, cameraFlipBtn, swapBtn, inviteBtn, listenerCountBtn, endBtn].forEach(btn => {
          if(btn) btn.hidden = false;
        });
        document.documentElement.style.setProperty('--header-height', headerBar.offsetHeight + 'px');
        document.documentElement.style.setProperty('--footer-height', footerBar.offsetHeight + 'px');
      }
    updateHeaderButtons();
    window.addEventListener('resize', () => {
      document.documentElement.style.setProperty('--header-height', headerBar.offsetHeight + 'px');
      document.documentElement.style.setProperty('--footer-height', footerBar.offsetHeight + 'px');
    });

    function updateUsers(list){
        userCache = list;
        const selfLive = list.some(u => typeof u !== 'string' && u.id === clientId && u.live);
        liveCount.textContent = list.length - (selfLive ? 1 : 0);
        usersEl.innerHTML = '';
        const liveIds = new Set();
        list.forEach(u => {
          const name = typeof u === 'string' ? u : u.name;
          const id = typeof u === 'string' ? u : u.id;
          if(u.live){
            liveIds.add(id);
            ensureStreamThumb(id, name, id === clientId);
            if(id === clientId) return;
          }
          const li = document.createElement('li');
          if(u.live){
            const dot = document.createElement('span');
            dot.className = 'live-dot';
            li.appendChild(dot);
            const camIcon = document.createElement('span');
            camIcon.textContent = 'üé•';
            camIcon.title = 'Camera';
            li.appendChild(camIcon);
          }
          if(u.mic){
            li.classList.add('mic-user');
            const micIcon = document.createElement('span');
            micIcon.textContent = 'üé§';
            micIcon.title = 'Mic';
            li.appendChild(micIcon);
          }
          const nameSpan = document.createElement('span');
          nameSpan.textContent = '@' + name;
          li.appendChild(nameSpan);
          if(u.live){
            li.addEventListener('click', () => watchLive(guestMap[id] || id, name));
          }
          if(u.live && id !== clientId){
            const camBtn = document.createElement('button');
            camBtn.title = 'Request to join with camera';
            camBtn.innerHTML = '<img src="static/camera.svg" alt="Join with camera" />';
            camBtn.addEventListener('click', e => {
              e.stopPropagation();
              currentHost = id;
              pendingJoinHost = id;
              sendSignal({ type: 'join-request', id, user: store.user });
              systemNote('Join request sent');
            });
            li.appendChild(camBtn);
            const micBtn = document.createElement('button');
            micBtn.title = 'Request to join with mic';
            micBtn.innerHTML = '<img src="static/mic.svg" alt="Request mic" />';
            micBtn.addEventListener('click', e => {
              e.stopPropagation();
              currentHost = id;
              pendingMicHost = id;
              sendSignal({ type: 'mic-request', id, user: store.user });
              systemNote('Mic request sent');
            });
            li.appendChild(micBtn);
          }
          usersEl.appendChild(li);
        });
        for(const id in streams){
          if(!liveIds.has(id)){
            streams[id].container.remove();
            delete streams[id];
          }
        }
      }

      function ensureStreamThumb(id, name, isSelf=false){
        if(streams[id]) return;
        const div = document.createElement('div');
        div.className = 'stream';
        div.innerHTML = `<div class="title">@${name} (<span class="listener-count">0</span>)</div><img class="thumb" alt="thumbnail" /><div class="video"></div><div class="join-btns"><button class="cam-btn chip" type="button" title="Request to join with camera"><img src="static/camera.svg" alt="Join with camera" /></button><button class="mic-btn chip" type="button" title="Request to join with mic"><img src="static/mic.svg" alt="Request mic" /></button></div><button class="tune-btn chip" type="button">Tune In</button><ul class="stream-feed"></ul><form class="stream-composer"><input type="text" placeholder="Comment" /><button type="submit">Send</button></form>`;
        const videoBox = div.querySelector('.video');
        const thumbEl = div.querySelector('.thumb');
        thumbEl.setAttribute('hidden','');
        const feed = div.querySelector('.stream-feed');
        const form = div.querySelector('.stream-composer');
        const input = form.querySelector('input');
        const count = div.querySelector('.listener-count');
        const tuneBtn = div.querySelector('.tune-btn');
        const camBtn = div.querySelector('.cam-btn');
        const micBtn = div.querySelector('.mic-btn');
        const joinBtns = div.querySelector('.join-btns');
        form.addEventListener('submit', ev => {
          ev.preventDefault();
          const text = input.value.trim();
          if(!text) return;
          postMessage({ text, room: id });
          input.value='';
        });
        if(!isSelf){
          camBtn.addEventListener('click', () => {
            sendSignal({ type: 'join-request', id, user: store.user });
          });
          micBtn.addEventListener('click', () => {
            sendSignal({ type: 'mic-request', id, user: store.user });
          });
          camBtn.hidden = true;
          micBtn.hidden = true;
          if(joinBtns) joinBtns.hidden = true;
          tuneBtn.addEventListener('click', () => {
            if(streams[id].started){
              endWatching(id);
              streams[id].started = false;
              div.classList.remove('open');
              tuneBtn.textContent = 'Tune In';
              camBtn.hidden = true;
              micBtn.hidden = true;
              if(joinBtns) joinBtns.hidden = true;
            } else {
              startWatching(id);
              streams[id].started = true;
              div.classList.add('open');
              tuneBtn.textContent = 'Leave';
              camBtn.hidden = false;
              micBtn.hidden = false;
              if(joinBtns) joinBtns.hidden = false;
            }
          });
        } else {
          tuneBtn.style.display = 'none';
          camBtn.style.display = 'none';
          micBtn.style.display = 'none';
          if(joinBtns) joinBtns.style.display = 'none';
        }
        if(pendingThumbs[id]){ thumbEl.src = pendingThumbs[id]; thumbEl.removeAttribute('hidden'); delete pendingThumbs[id]; }
        (isSelf ? selfStreamEl : streamsEl).appendChild(div);
        streams[id] = { container: div, video: videoBox, feed, input, count, self: isSelf, started:false, vid: null, captionTrack: null, thumbEl };
        if(isSelf){
          div.classList.add('open');
          streams[id].started = true;
        }
      }
      function chooseThumbnail(){
        return new Promise(resolve => {
          thumbChooser.hidden = false;

          function cleanup(){
            thumbChooser.hidden = true;
            thumbUpload.removeEventListener('click', onUpload);
            thumbCamera.removeEventListener('click', onCamera);
            thumbSkip.removeEventListener('click', onSkip);
          }

          function pick(capture){
            thumbChooser.hidden = true;
            const inp = document.createElement('input');
            inp.type = 'file';
            inp.accept = 'image/*';
            if(capture) inp.capture = 'environment';
            inp.onchange = () => {
              const file = inp.files[0];
              cleanup();
              if(!file){ resolve(null); return; }
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.readAsDataURL(file);
            };
            inp.click();
          }

          function onUpload(){ pick(false); }
          function onCamera(){ pick(true); }
          function onSkip(){ cleanup(); resolve(null); }

          thumbUpload.addEventListener('click', onUpload, { once: true });
          thumbCamera.addEventListener('click', onCamera, { once: true });
          thumbSkip.addEventListener('click', onSkip, { once: true });
        });
      }

      function handleThumbnail(id, thumb){
        if(streams[id]){
          streams[id].thumbEl.src = thumb;
          streams[id].thumbEl.removeAttribute('hidden');
        } else {
          pendingThumbs[id] = thumb;
        }
      }

      // open stream bubble programmatically if needed
      function watchLive(id, name){
        ensureStreamThumb(id, name, id === clientId);
        streams[id].container.classList.add('open');
        if(!streams[id].started && !streams[id].self){
          startWatching(id);
          streams[id].started = true;
        }
      }

      function updateListenerCount(id, n){
        if(streams[id]) streams[id].count.textContent = n;
        if(id === clientId && listenerCountSpan) listenerCountSpan.textContent = n;
      }
    function sendJoin(){
      try { socket && socket.readyState === 1 && socket.send(JSON.stringify({ type:'join', user: store.user })); } catch {}
    }

    function defaultWS(){
      const host = (location.hostname && !/localhost|127\\.0\\.0\\.1/.test(location.hostname))
        ? 'chaines-io-chat.onrender.com'
        : location.host;
      const proto = location.protocol === 'https:' ? 'wss://' : 'ws://';
      return proto + host + '/ws';
    }

    function setStatus(mode){
      onlineMode = mode;
      if(mode === 'cloud'){
        connLabel.textContent = 'Cloud';
        connIcon.src = 'static/cloud.svg';
      } else if(mode === 'local'){
        connLabel.textContent = 'Local';
        connIcon.src = 'static/home.svg';
        updateUsers([]);
      } else {
        connLabel.textContent = 'Offline';
        connIcon.src = 'static/home.svg';
        updateUsers([]);
      }
      if(mode !== 'cloud') renderHistory();
    }

    function connectWS(){
      const url = store.wsURL;
      if(!('WebSocket' in window)) return setStatus('off');
      try {
        socket = new WebSocket(url);
      } catch { setStatus('off'); return; }

      socket.addEventListener('open', () => { setStatus('cloud'); sendJoin(); });
      socket.addEventListener('close', () => { setStatus(bc? 'local' : 'off'); });
      socket.addEventListener('error', () => { setStatus(bc? 'local' : 'off'); });
      socket.addEventListener('message', ev => {
        try {
          const data = JSON.parse(ev.data);
          if(data && data.type === 'chat') receive(data);
          if(data && data.type === 'comment') handleComment(data);
          if(data && data.type === 'like') handleLike(data);
          if(data && data.type === 'caption') handleCaption(data);
          if(data && data.type === 'system') systemNote(data.text);
          if(data && data.type === 'users') updateUsers(data.users || []);
          if(data && data.type === 'count') liveCount.textContent = data.count;
          if(data && data.type === 'history') {
            const msgs = data.messages || [];
            if(msgs.some(m => m.room)){
              msgs.forEach(m => receive(m));
            } else {
              feed.innerHTML = '';
              msgs.forEach(m => receive(m));
            }
          }
          if(data && data.type === 'id') clientId = data.id;
          if(data && data.type === 'listeners') updateListenerCount(data.id, data.count);
          if(data && data.type === 'watcher') handleWatcher(data.id);
          if(data && data.type === 'offer') handleOffer(data);
          if(data && data.type === 'answer') handleAnswer(data);
          if(data && data.type === 'candidate') handleCandidate(data);
          if(data && data.type === 'bye') handleBye(data);
          if(data && data.type === 'join-request') handleJoinRequest(data.id, data.user);
          if(data && data.type === 'join-approved') handleJoinApproved();
          if(data && data.type === 'join-denied') handleJoinDenied();
          if(data && data.type === 'mic-request') handleMicRequest(data.id, data.user);
          if(data && data.type === 'mic-approved') handleMicApproved();
          if(data && data.type === 'mic-denied') handleMicDenied();
          if(data && data.type === 'invite') handleInvite(data);
          if(data && data.type === 'thumb') handleThumbnail(data.id, data.thumb);
          if(data && data.type === 'guest-start') handleGuestStart(data);
          if(data && data.type === 'delete') {
            const el = feed.querySelector(`li[data-id="${data.id}"]`);
            if(el) el.remove();
            store.removeMsg(data.id);
          }
          if(data && data.type === 'self-destruct') {
            systemNote(`Your post #${data.messageId} self-destructed`);
          }
        } catch {}
      });
    }

    function setupLocal(){
      if(!('BroadcastChannel' in window)) { setStatus('off'); return; }
      bc = new BroadcastChannel('chaines_chat');
      bc.onmessage = (ev) => {
        const m = ev.data; if(m && m.type === 'chat') receive(m);
      };
      if(onlineMode !== 'cloud') setStatus('local');
    }

    // --- Auth flow ---
    function requireAuth(){
      if (store.user) {
        enterChat(store.user, store.profilePic);
      } else {
        auth.hidden = false;
        auth.classList.remove('is-hidden');
        auth.style.display = 'flex';
        const top = headerBar.offsetHeight;
        const bottom = footerBar.offsetHeight;
        auth.style.top = top + 'px';
        auth.style.bottom = bottom + 'px';
        document.body.classList.add('auth-lock');
        setTimeout(() => usernameInput && usernameInput.focus(), 50);
      }
    }

    function enterChat(name, profilePic){
      const cleaned = (name || '').replace(/[^a-zA-Z0-9_\-.]/g,'').slice(0,24);
      store.user = cleaned || ('guest-' + Math.floor(Math.random()*9999));
      if(profilePic) store.profilePic = profilePic; else if(!store.profilePic) store.profilePic = '';
      if(profileLink){
        profileLink.href = '/profile.html?user=' + encodeURIComponent(store.user);
        profileNameEl.textContent = '@' + store.user;
        if(store.profilePic){
          profilePicEl.src = store.profilePic;
          profilePicEl.hidden = false;
        } else {
          profilePicEl.hidden = true;
        }
      }

      document.body.classList.remove('auth-lock');
      document.documentElement.style.zoom = '1';
      window.scrollTo(0,0);

      // decisively hide overlay
      auth.classList.add('is-hidden');
      auth.setAttribute('hidden','');
      auth.style.display = 'none';

      renderHistory();
      if (!socket || socket.readyState > 1) connectWS();
      else sendJoin();
      if (!bc) setupLocal();
      input && input.focus();
      systemNote(`You are signed in as @${store.user}.`);
      setupPush();
    }

    async function setupPush(){
      if(!('serviceWorker' in navigator) || !('PushManager' in window)) return;
      try {
        const prefRes = await fetch('/notification-settings/' + encodeURIComponent(store.user));
        const pref = await prefRes.json().catch(()=>({}));
        if(!pref.push) return;
        const perm = await Notification.requestPermission();
        if(perm !== 'granted') return;
        const reg = await navigator.serviceWorker.register('/sw.js');
        const res = await fetch('/push/key');
        const data = await res.json().catch(()=>({}));
        if(!data.key) return;
        const sub = await reg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(data.key)
        });
        await fetch('/push/subscribe', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ username: store.user, subscription: sub })
        });
      } catch{}
    }

    function urlBase64ToUint8Array(base64String){
      const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function doLogin(){
      const name = (usernameInput.value || '').replace(/[^a-zA-Z0-9_\-.]/g,'').slice(0,24);
      const pass = passwordInput.value;
      if(!name || !pass){ alert('Username and password required'); return; }
      const res = await fetch('/login', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ username: name, password: pass })
      });
      const data = await res.json().catch(()=>null);
      if(res.ok && data && data.success){
        enterChat(data.username, data.profilePic);
      } else {
        alert(data?.error || 'Login failed');
      }
    }

    loginBtn.addEventListener('click', (e) => { e.preventDefault(); doLogin(); });

    registerBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      const name = (usernameInput.value || '').replace(/[^a-zA-Z0-9_\-.]/g,'').slice(0,24);
      const pass = passwordInput.value;
      if(!name || !pass){ alert('Username and password required'); return; }
      const fd = new FormData();
      fd.append('username', name);
      fd.append('password', pass);
      if(profileInput.files[0]) fd.append('profile', profileInput.files[0]);
      const res = await fetch('/register', { method:'POST', body: fd });
      if(res.ok){ await doLogin(); }
      else {
        const data = await res.json().catch(()=>({}));
        alert(data.error || 'Registration failed');
      }
    });

    skipBtn.addEventListener('click', (e) => {
      e.preventDefault();
      store.profilePic='';
      enterChat('guest-' + Math.floor(Math.random()*9999));
    });

    // Enter key on fields
    [usernameInput, passwordInput].forEach(inp => inp.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); loginBtn.click(); }
    }));

    logoutBtn.addEventListener('click', (e) => { e.preventDefault(); store.user=''; store.profilePic=''; location.reload(); });

    wsEdit.addEventListener('click', () => {
      wsCfg.style.display = wsCfg.style.display==='none' ? 'grid' : 'none';
      wsUrlInput.value = store.wsURL;
    });
    el('#save-ws').addEventListener('click', (e) => {
      e.preventDefault();
      store.wsURL = wsUrlInput.value.trim();
      alert('Saved WebSocket URL.');
    });

    // --- Messaging ---
    form.addEventListener('submit', ev => {
      ev.preventDefault();
      if(fileLoading) return;
      const raw = (input.value || '').trim();
      if(!raw && !pendingFile) return;

      if(raw){
        // Commands
        if(raw === '/clear'){ store.clearMsgs(); feed.innerHTML=''; input.value=''; input.placeholder = defaultPlaceholder; pendingFile=null; systemNote('Cleared local chat history.'); return; }
        if(/^\s*\/me\s+/.test(raw)){
          const act = raw.replace(/^\s*\/me\s+/, '');
          postMessage({ text: `*${act}*`, isAction:true });
          input.value='';
          input.placeholder = defaultPlaceholder;
          pendingFile = null;
          return;
        }
        const simpleCmd = raw.match(/^\/([a-z]+)$/i);
        if(simpleCmd){
          const entry = actionCommands[simpleCmd[1].toLowerCase()];
          if(entry){
            postMessage({ text: `*${entry.text}*`, isAction:true });
            input.value='';
            input.placeholder = defaultPlaceholder;
            pendingFile = null;
            return;
          }
        }
      }

      const msg = { text: raw, broadcast: broadcasting };
      if(pendingFile){
        msg.file = pendingFile.dataUrl;
        msg.fileName = pendingFile.name;
        msg.fileType = pendingFile.type;
        if(pendingFile.type.startsWith('image/')){
          msg.image = pendingFile.dataUrl;
          msg.name = pendingFile.name;
        }
      }
      postMessage(msg);
      input.value = '';
      input.placeholder = defaultPlaceholder;
      pendingFile = null;
    });

    broadcastComposer.addEventListener('submit', ev => {
      ev.preventDefault();
      const raw = (broadcastInput.value || '').trim();
      if(!raw) return;
      postMessage({ text: raw, broadcast: true });
      broadcastInput.value = '';
    });

    cmdListBtn.addEventListener('click', () => {
      cmdPanel.hidden = !cmdPanel.hidden;
    });
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file) return;
      fileLoading = true;
      sendBtn.disabled = true;
      const reader = new FileReader();
      reader.onload = () => {
        pendingFile = { dataUrl: reader.result, name: file.name, type: file.type };
        input.placeholder = `Comment on ${file.name}`;
        input.focus();
        fileLoading = false;
        sendBtn.disabled = false;
      };
      reader.onerror = () => {
        fileLoading = false;
        sendBtn.disabled = false;
      };
      reader.readAsDataURL(file);
      fileInput.value = '';
    });

      function postMessage({ text='', image, file, fileName, fileType, name, isAction=false, broadcast=false, video, room }){
      if(broadcast){
        room = joinApproved && pendingJoinHost ? pendingJoinHost : clientId;
      }
      const msg = {
        id: Date.now().toString(36) + Math.random().toString(36).slice(2,7),
        type: 'chat',
        user: store.user,
        profilePic: store.profilePic,
          text: text,
          room: room,
        image: image,
        file: file,
        fileName: fileName || name,
        fileType: fileType,
        name: fileName || name,
        isAction,
        broadcast,
        video,
        ts: Date.now(),
        likes: 0,
        comments: []
      };
      if(store.autoDelete) msg.selfDestruct = 5 * 60 * 1000;

      // Push to UI + storage immediately
        receive(msg, true);
        if(!room) store.pushMsg(msg);

      // Broadcast locally
      try { bc && bc.postMessage(msg); } catch {}

      // Send to server if available
        try { if(socket && socket.readyState === 1) socket.send(JSON.stringify(msg)); } catch {}
      }

    // --- WebRTC helpers ---
      function startBroadcast(stream, audioOnly=false){
        if(broadcasting) return;
        overlayMessages = [];
        cameraOff = false;
        blankTrack = null;
        broadcasting = true;
        if(joinControls) joinControls.setAttribute('hidden','');
        const getStream = stream ? Promise.resolve(stream) : navigator.mediaDevices.getUserMedia(audioOnly ? { audio: true } : { video: { facingMode: usingFrontCamera ? 'user' : 'environment' }, audio: true });
        getStream.then(stream => {
          localStream = stream;
          if(pendingWatchers.size){
            pendingWatchers.forEach(id => handleWatcher(id));
            pendingWatchers.clear();
          }
          recordedChunks = [];
          if(!audioOnly){
            recordCanvas = document.createElement('canvas');
            recordCtx = recordCanvas.getContext('2d');
            const draw = () => {
              const vids = videoContainer.querySelectorAll('video');
              let w = 0, h = 0;
              vids.forEach(v => { w += v.videoWidth || 0; h = Math.max(h, v.videoHeight || 0); });
              if(w && h){
                recordCanvas.width = w;
                recordCanvas.height = h;
                let x = 0;
                vids.forEach(v => {
                  try { recordCtx.drawImage(v, x, 0, v.videoWidth || 0, h); } catch{}
                  x += v.videoWidth || 0;
                });
                const now = Date.now();
                overlayMessages = overlayMessages.filter(m => now - m.ts < 5000);
                if(overlayMessages.length){
                  recordCtx.font = '20px Poppins, sans-serif';
                  recordCtx.textBaseline = 'bottom';
                  let y = recordCanvas.height - 10;
                  overlayMessages.forEach(msg => {
                    const padding = 8;
                    const metrics = recordCtx.measureText(msg.text);
                    const height = 24;
                    const width = metrics.width + padding * 2;
                    const xPos = 10;
                    const yPos = y;
                    recordCtx.fillStyle = 'rgba(0,0,0,0.6)';
                    recordCtx.fillRect(xPos, yPos - height, width, height);
                    recordCtx.fillStyle = '#fff';
                    recordCtx.fillText(msg.text, xPos + padding, yPos - 6);
                    y -= height + 4;
                  });
                }
              }
              drawHandle = requestAnimationFrame(draw);
            };
            draw();
            try {
              const canvasStream = recordCanvas.captureStream(30);
              stream.getAudioTracks().forEach(track => canvasStream.addTrack(track));
              const mime = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1') ? 'video/mp4' : 'video/webm';
              mediaRecorder = new MediaRecorder(canvasStream, { mimeType: mime });
              recordMime = mime;
              mediaRecorder.ondataavailable = e => { if(e.data.size) recordedChunks.push(e.data); };
              mediaRecorder.start();
            } catch {}
          }
      updateListenerCount(clientId, 0);
      activeRooms.add(clientId);
      feed.setAttribute('hidden','');
      document.body.classList.remove('chat-open');
      if(broadcastComposer) broadcastComposer.removeAttribute('hidden');
      if(store.autoDelete){ broadcastTimer = setTimeout(() => endBroadcast(true), 5 * 60 * 1000); }
      broadcastBtn.textContent = '‚èπ End';
      broadcastBtn.title = 'End live broadcast';
      broadcastBtn.classList.add('live');
      if(endBtn) endBtn.classList.add('live');
      updateHeaderButtons();
      if(!audioOnly) document.body.classList.add('broadcast-mode');
      videoContainer.removeAttribute('hidden');
      if(videoToggle) videoToggle.textContent = streamTiles.hasAttribute('hidden') ? 'Show Feed' : 'Hide Feed';
      broadcastControls.removeAttribute('hidden');
      if(cameraBtn){
        cameraBtn.hidden = audioOnly;
        cameraBtn.classList.remove('off');
        cameraBtn.title = 'Turn camera off';
      }
      if(overlayChat) overlayChat.removeAttribute('hidden');
      const mediaEl = document.createElement(audioOnly ? 'audio' : 'video');
      mediaEl.srcObject = stream;
      mediaEl.muted = true;
          mediaEl.setAttribute('muted','');
          mediaEl.autoplay = true;
          mediaEl.setAttribute('autoplay','');
          mediaEl.playsInline = true;
          mediaEl.setAttribute('playsinline','');
          mediaEl.controls = true;
          if(!audioOnly){
            attachCaptions(mediaEl);
            captionTrack = mediaEl.addTextTrack('captions', 'Live', (document.documentElement.lang||'en').slice(0,2));
            captionTrack.mode = 'showing';
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if(SpeechRecognition){
              speechRec = new SpeechRecognition();
              speechRec.lang = document.documentElement.lang || 'en-US';
              speechRec.continuous = true;
              speechRec.interimResults = false;
              speechRec.addEventListener('result', e => {
                const transcript = Array.from(e.results).map(r => r[0].transcript).join('').trim();
                if(transcript && captionTrack){
                  const Cue = window.VTTCue || window.TextTrackCue;
                  try{ captionTrack.addCue(new Cue(mediaEl.currentTime, mediaEl.currentTime+5, transcript)); }
                  catch(err){ console.error('cue error', err); }
                  try{ sendSignal({ type: 'caption', text: transcript }); }catch{}
                }
              });
              speechRec.addEventListener('error', err => console.error('speech error', err));
              try{ speechRec.start(); }catch{}
            }
          }
          const hostCanvas = el('#host-canvas');
          if(hostCanvas){
            hostCanvas.innerHTML = '';
            hostCanvas.appendChild(mediaEl);
          } else {
            videoContainer.appendChild(mediaEl);
          }
          // also show our local stream in the self tile so it appears in the tiles list
          const selfStream = streams[clientId];
          if(selfStream){
            const tileEl = document.createElement(audioOnly ? 'audio' : 'video');
            tileEl.srcObject = stream;
            tileEl.muted = true;
            tileEl.setAttribute('muted','');
            tileEl.autoplay = true;
            tileEl.setAttribute('autoplay','');
            tileEl.playsInline = true;
            tileEl.setAttribute('playsinline','');
            tileEl.controls = true;
            selfStream.video.innerHTML = '';
            selfStream.video.appendChild(tileEl);
            if(!audioOnly){
              attachCaptions(tileEl);
              selfStream.captionTrack = tileEl.addTextTrack('captions', 'Live', (document.documentElement.lang||'en').slice(0,2));
              selfStream.captionTrack.mode = 'showing';
            }
            selfStream.vid = tileEl;
            selfStream.started = true;
            updateVideoLayout(selfStream.video);
          }
          updateVideoLayout();
          const start = mediaEl.play();
          if(start && start.catch){ start.catch(() => {}); }
          broadcastVideo = mediaEl;
          sendSignal({ type: audioOnly ? 'mic-broadcaster' : 'broadcaster' });
          if(!pendingJoinHost) postMessage({ text: 'üî¥ Broadcast started' });
        }).catch(() => {
          broadcasting = false;
          if(joinControls) joinControls.removeAttribute('hidden');
          if(joinCamBtn) joinCamBtn.disabled = false;
          if(joinMicBtn) joinMicBtn.disabled = false;
          alert('Unable to access camera/microphone');
        });
      }

      function switchCamera(){
        if(!localStream) return;
        usingFrontCamera = !usingFrontCamera;
        const videoTrack = localStream.getVideoTracks()[0];
        const audioTracks = localStream.getAudioTracks();
        if(videoTrack) videoTrack.stop();
        navigator.mediaDevices.getUserMedia({ video: { facingMode: usingFrontCamera ? 'user' : 'environment' }, audio: false })
          .then(stream => {
            const newVideoTrack = stream.getVideoTracks()[0];
            localStream = new MediaStream([...audioTracks, newVideoTrack]);
            if(broadcastVideo) broadcastVideo.srcObject = localStream;
            for(const id in peerConnections){
              const sender = peerConnections[id].getSenders().find(s => s.track && s.track.kind === 'video');
              if(sender) sender.replaceTrack(newVideoTrack);
            }
          }).catch(() => alert('Unable to switch camera'));
      }

      function toggleCamera(){
        if(!localStream) return;
        const videoTrack = localStream.getVideoTracks()[0];
        if(!cameraOff){
          if(!videoTrack) return;
          const settings = videoTrack.getSettings();
          const canvas = document.createElement('canvas');
          canvas.width = settings.width || 640;
          canvas.height = settings.height || 480;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'black';
          ctx.fillRect(0,0,canvas.width,canvas.height);
          blankTrack = canvas.captureStream().getVideoTracks()[0];
          videoTrack.stop();
          localStream.removeTrack(videoTrack);
          localStream.addTrack(blankTrack);
          for(const id in peerConnections){
            const sender = peerConnections[id].getSenders().find(s => s.track && s.track.kind === 'video');
            if(sender) sender.replaceTrack(blankTrack);
          }
          if(broadcastVideo) broadcastVideo.srcObject = localStream;
          cameraOff = true;
          if(cameraBtn){ cameraBtn.classList.add('off'); cameraBtn.title = 'Turn camera on'; }
        } else {
          navigator.mediaDevices.getUserMedia({ video: { facingMode: usingFrontCamera ? 'user' : 'environment' }, audio: false })
            .then(stream => {
              const newVideoTrack = stream.getVideoTracks()[0];
              if(blankTrack){
                localStream.removeTrack(blankTrack);
                blankTrack.stop();
                blankTrack = null;
              }
              localStream.addTrack(newVideoTrack);
              for(const id in peerConnections){
                const sender = peerConnections[id].getSenders().find(s => s.track && s.track.kind === 'video');
                if(sender) sender.replaceTrack(newVideoTrack);
              }
              if(broadcastVideo) broadcastVideo.srcObject = localStream;
              cameraOff = false;
              if(cameraBtn){ cameraBtn.classList.remove('off'); cameraBtn.title = 'Turn camera off'; }
            })
            .catch(() => alert('Unable to access camera'));
        }
      }

      function endBroadcast(forced=false){
        if(broadcastTimer){ clearTimeout(broadcastTimer); broadcastTimer = null; }
        if(!broadcasting) return;
        broadcasting = false;
        if(cameraBtn){
          cameraBtn.hidden = true;
          cameraBtn.classList.remove('off');
          cameraBtn.title = 'Turn camera off';
        }
        cameraOff = false;
        if(blankTrack){ blankTrack.stop(); blankTrack = null; }
      overlayMessages = [];
      activeRooms.delete(clientId);
      if(activeRooms.size === 0) feed.removeAttribute('hidden');
      updateHeaderButtons();
      joinApproved = false;
      micApproved = false;
      pendingJoinHost = null;
      pendingMicHost = null;
      broadcastBtn.disabled = false;
      broadcastBtn.textContent = 'üé• Go Live';
      broadcastBtn.title = 'Go live';
      if(joinCamBtn) joinCamBtn.disabled = false;
      if(joinMicBtn) joinMicBtn.disabled = false;
        broadcastBtn.classList.remove('live');
        if(endBtn) endBtn.classList.remove('live');
        broadcastVideo = null;
        const share = forced ? true :
          confirm('Post to chat?\nPress OK to post or Cancel to delete.');
        const note = forced ? new Date().toLocaleString() : (share ?
          (prompt('Broadcast end comment?') || '').trim() : '');

      const vidCount = videoContainer.querySelectorAll('video').length;
      const baseText = `‚èπ Broadcast ended${note ? ': '+note : ''}`;
      const msgText = vidCount > 1 ? `${baseText} (multi-cam)` : baseText;
      const hadRecorder = !!mediaRecorder;
      if(mediaRecorder){
          mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: recordMime });
          const reader = new FileReader();
          reader.onloadend = () => {
            const dataUrl = reader.result;
            if(share){
              postMessage({
                text: msgText,
                video: dataUrl,
                file: dataUrl,
                fileName: `broadcast-${Date.now()}.${recordMime === 'video/mp4' ? 'mp4' : 'webm'}`,
                fileType: recordMime,
                image: broadcastThumb
              });
            }
          };
          reader.readAsDataURL(blob);
        };
        try { mediaRecorder.stop(); } catch {}
        mediaRecorder = null;
      }
      if(drawHandle) cancelAnimationFrame(drawHandle);
      drawHandle = null;
      if(localStream){
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      for(const id in peerConnections){
        try{ peerConnections[id].close(); }catch{}
        delete peerConnections[id];
      }
      sendSignal({ type: 'end-broadcast' });
      const hostCanvas = el('#host-canvas');
      if(hostCanvas) hostCanvas.innerHTML = '';
      const guestCanvas = el('#guest-canvas');
      if(guestCanvas){ guestCanvas.innerHTML = ''; guestCanvas.setAttribute('hidden',''); }
      updateVideoLayout();
      videoContainer.setAttribute('hidden','');
      if(videoToggle) videoToggle.textContent = streamTiles.hasAttribute('hidden') ? 'Show Feed' : 'Hide Feed';
      document.body.classList.remove('broadcast-mode');
      document.body.classList.remove('chat-open');
      broadcastControls.setAttribute('hidden','');
      if(overlayChat){ overlayChat.innerHTML = ''; overlayChat.setAttribute('hidden',''); }
      if(broadcastComposer) broadcastComposer.setAttribute('hidden','');
      if(speechRec){ try{ speechRec.stop(); }catch{} speechRec = null; }
      captionTrack = null;
      if(!hadRecorder && share){
        postMessage({ text: msgText, image: broadcastThumb });
      }
      const selfStream = streams[clientId];
      if(selfStream){
        selfStream.feed.innerHTML = '';
        selfStream.container.remove();
        delete streams[clientId];
      }
      if(joinControls && activeRooms.size > 0) joinControls.removeAttribute('hidden');
      broadcastThumb = null;
    }

      function updateVideoLayout(container = videoContainer){
        const vids = container.querySelectorAll('video');
        const multi = vids.length > 1;
        if(container === videoContainer){
          vids.forEach(v => v.style.display = '');
          container.classList.toggle('has-guest', multi && layoutMode === 'split');
          container.classList.toggle('pip', multi && layoutMode === 'pip');
          const guestCanvas = el('#guest-canvas');
          if(guestCanvas) guestCanvas.hidden = guestCanvas.querySelectorAll('video').length === 0;
          vids.forEach(v => v.onclick = null);
          if(multi){
            vids.forEach(v => v.onclick = swapVideos);
          }
          if(swapBtn) swapBtn.hidden = !multi;
          if(swapBtn) swapBtn.title = layoutTitles[layoutMode];
        } else {
          container.classList.toggle('has-guest', multi && layoutMode === 'split');
          container.classList.toggle('pip', multi && layoutMode === 'pip');
        }
      }

    function swapVideos(){
      const idx = layouts.indexOf(layoutMode);
      layoutMode = layouts[(idx + 1) % layouts.length];
      updateVideoLayout();
    }

      function startWatching(id){
        activeRooms.add(id);
        currentHost = id;
        const stream = streams[id];
        if(stream && !stream.started){
          stream.started = true;
          stream.container.classList.add('open');
          const tuneBtn = stream.container.querySelector('.tune-btn');
          if(tuneBtn) tuneBtn.textContent = 'Leave';
          const camBtn = stream.container.querySelector('.cam-btn');
          const micBtn = stream.container.querySelector('.mic-btn');
          if(camBtn) camBtn.hidden = false;
          if(micBtn) micBtn.hidden = false;
          const joinBtns = stream.container.querySelector('.join-btns');
          if(joinBtns) joinBtns.hidden = false;
        }
        if(!broadcasting){
          feed.setAttribute('hidden','');
          if(joinControls) joinControls.removeAttribute('hidden');
          videoContainer && videoContainer.removeAttribute('hidden');
          const guestCanvas = el('#guest-canvas');
          if(guestCanvas){ guestCanvas.innerHTML = ''; guestCanvas.setAttribute('hidden',''); }
          if(videoToggle) videoToggle.textContent = streamTiles.hasAttribute('hidden') ? 'Show Feed' : 'Hide Feed';
        }
        sendSignal({ type: 'watcher', id });
      }

      function endWatching(id){
        activeRooms.delete(id);
        if(activeRooms.size === 0){
          feed.removeAttribute('hidden');
          if(joinControls) joinControls.setAttribute('hidden','');
          currentHost = null;
          if(videoToggle) videoToggle.textContent = streamTiles.hasAttribute('hidden') ? 'Show Feed' : 'Hide Feed';
          if(!broadcasting){
            const hostCanvas = el('#host-canvas');
            if(hostCanvas) hostCanvas.innerHTML = '';
            const guestCanvas = el('#guest-canvas');
            if(guestCanvas){ guestCanvas.innerHTML = ''; guestCanvas.setAttribute('hidden',''); }
            videoContainer && videoContainer.setAttribute('hidden','');
          }
        } else if(currentHost === id){
          currentHost = [...activeRooms][0];
        }
        sendSignal({ type: 'unwatcher', id });
      }

    function handleWatcher(id){
      if(!localStream){
        pendingWatchers.add(id);
        return;
      }
      const pc = new RTCPeerConnection();
      peerConnections[id] = pc;
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      pc.onicecandidate = e => { if(e.candidate) sendSignal({ type:'candidate', id, candidate: e.candidate }); };
      pc.createOffer().then(o => pc.setLocalDescription(o)).then(() => {
        sendSignal({ type:'offer', id, sdp: pc.localDescription });
      });
    }

      function handleOffer(msg){
        let pc = peerConnections[msg.id];
        if(!pc){
          pc = new RTCPeerConnection();
          peerConnections[msg.id] = pc;
          pc.ontrack = ev => {
            const stream = ev.streams[0];
            if(broadcasting){
              if(ev.track.kind === 'video'){
                const vid = document.createElement('video');
                vid.srcObject = stream;
                vid.autoplay = true;
                vid.setAttribute('autoplay','');
                vid.playsInline = true;
                vid.setAttribute('playsinline','');
                vid.controls = true;
                attachCaptions(vid);
                const liveTrack = vid.addTextTrack('captions', 'Live', (document.documentElement.lang||'en').slice(0,2));
                liveTrack.mode = 'showing';
                const guestCanvas = el('#guest-canvas');
                if(guestCanvas){
                  guestCanvas.innerHTML = '';
                  guestCanvas.appendChild(vid);
                } else {
                  videoContainer.appendChild(vid);
                }
                updateVideoLayout();
                try{ localStream && localStream.addTrack(ev.track); }catch{}
                for(const id in peerConnections){
                  if(id === msg.id) continue;
                  try{
                    const pc2 = peerConnections[id];
                    pc2.addTrack(ev.track, stream);
                    pc2.createOffer().then(o => pc2.setLocalDescription(o)).then(() => {
                      sendSignal({ type:'offer', id, sdp: pc2.localDescription });
                    });
                  }catch{}
                }
                // try to begin playback immediately (mobile requires user gesture)
                vid.muted = true;
                vid.setAttribute('muted','');
                const playPromise = vid.play();
                if(playPromise && playPromise.then){
                  playPromise.then(() => { vid.muted = false; vid.removeAttribute('muted'); }).catch(() => { vid.muted = false; vid.removeAttribute('muted'); });
                } else {
                  vid.muted = false;
                  vid.removeAttribute('muted');
                }
                pc._videos = pc._videos || [];
                pc._videos.push(vid);
              } else if(ev.track.kind === 'audio'){
                try{ localStream && localStream.addTrack(ev.track); }catch{}
              }
            } else {
              if(ev.track.kind === 'video'){
                const vid = document.createElement('video');
                vid.srcObject = stream;
                vid.autoplay = true;
                vid.setAttribute('autoplay','');
                vid.playsInline = true;
                vid.setAttribute('playsinline','');
                vid.controls = true;
                attachCaptions(vid);
                const liveTrack = vid.addTextTrack('captions', 'Live', (document.documentElement.lang||'en').slice(0,2));
                liveTrack.mode = 'showing';
                const hostCanvas = el('#host-canvas');
                const guestCanvas = el('#guest-canvas');
                if(guestMap[msg.id]){
                  if(guestCanvas){
                    guestCanvas.innerHTML = '';
                    guestCanvas.appendChild(vid);
                    guestCanvas.removeAttribute('hidden');
                  }
                } else {
                  if(hostCanvas){
                    hostCanvas.innerHTML = '';
                    hostCanvas.appendChild(vid);
                  }
                }
                videoContainer && videoContainer.removeAttribute('hidden');
                updateVideoLayout();
                vid.muted = true;
                vid.setAttribute('muted','');
                const playPromise = vid.play();
                if(playPromise && playPromise.then){
                  playPromise.then(() => { vid.muted = false; vid.removeAttribute('muted'); }).catch(() => { vid.muted = false; vid.removeAttribute('muted'); });
                } else {
                  vid.muted = false;
                  vid.removeAttribute('muted');
                }
                if(streams[msg.id]){
                  if(!streams[msg.id].vid) streams[msg.id].vid = vid;
                  streams[msg.id].captionTrack = liveTrack;
                }
                pc._videos = pc._videos || [];
                pc._videos.push(vid);
              } else if(ev.track.kind === 'audio'){
                const hostCanvas = el('#host-canvas');
                const guestCanvas = el('#guest-canvas');
                const box = guestMap[msg.id] ? guestCanvas : hostCanvas;
                if(box && !box.querySelector(`audio[data-guest="${msg.id}"]`)){
                  const aud = document.createElement('audio');
                  aud.srcObject = stream;
                  aud.autoplay = true;
                  aud.setAttribute('autoplay','');
                  aud.controls = true;
                  aud.dataset.guest = msg.id;
                  box.appendChild(aud);
                }
              }
            }
          };
          pc.onicecandidate = e => { if(e.candidate) sendSignal({ type:'candidate', id: msg.id, candidate: e.candidate }); };
        }
        pc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
          .then(() => pc.createAnswer())
          .then(ans => pc.setLocalDescription(ans))
          .then(() => { sendSignal({ type:'answer', id: msg.id, sdp: pc.localDescription }); });
      }

    function handleAnswer(msg){
      const pc = peerConnections[msg.id];
      if(pc) pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    }

    function handleCandidate(msg){
      const pc = peerConnections[msg.id];
      if(pc && msg.candidate) pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
    }

      function handleBye(msg){
        const pc = peerConnections[msg.id];
        if(pc){
          if(pc._videos) pc._videos.forEach(v => v.remove());
          pc.close();
          delete peerConnections[msg.id];
        }
        for(const id in peerConnections){
          const senders = peerConnections[id].getSenders();
          senders.forEach(s => { if(s.track && s.track.readyState === 'ended'){ try{ peerConnections[id].removeTrack(s); }catch{} } });
        }
        if(localStream){
          localStream.getTracks().forEach(t => { if(t.readyState === 'ended') try{ localStream.removeTrack(t); }catch{} });
        }
        activeRooms.delete(msg.id);
        if(activeRooms.size === 0){
          feed.removeAttribute('hidden');
          if(!broadcasting){
            const hostCanvas = el('#host-canvas');
            if(hostCanvas) hostCanvas.innerHTML = '';
            const guestCanvas = el('#guest-canvas');
            if(guestCanvas){ guestCanvas.innerHTML = ''; guestCanvas.setAttribute('hidden',''); }
            videoContainer && videoContainer.setAttribute('hidden','');
          }
        }
        const guestCanvas = el('#guest-canvas');
        if(guestCanvas && guestCanvas.querySelector('video')){
          guestCanvas.innerHTML = '';
          guestCanvas.setAttribute('hidden','');
        }
        const host = guestMap[msg.id];
        if(host && streams[host]){
          streams[host].guestVid = null;
          updateVideoLayout(streams[host].video);
          if(streams[msg.id]){
            streams[msg.id].started = false;
            streams[msg.id].video.innerHTML = '';
            streams[msg.id].container.classList.remove('open');
            const t = streams[msg.id].container.querySelector('.tune-btn');
            if(t) t.textContent = 'Tune In';
            streams[msg.id].vid = null;
            streams[msg.id].captionTrack = null;
            updateVideoLayout(streams[msg.id].video);
          }
          delete guestMap[msg.id];
        } else {
          const hostCanvas = el('#host-canvas');
          if(!guestMap[msg.id] && hostCanvas && hostCanvas.querySelector('video')) hostCanvas.innerHTML = '';
          updateVideoLayout();
          if(streams[msg.id]){
            streams[msg.id].started = false;
            streams[msg.id].video.innerHTML = '';
            streams[msg.id].container.classList.remove('open');
            const t = streams[msg.id].container.querySelector('.tune-btn');
            if(t) t.textContent = 'Tune In';
            streams[msg.id].vid = null;
            streams[msg.id].captionTrack = null;
            updateVideoLayout(streams[msg.id].video);
          }
        }
        if((joinApproved && pendingJoinHost === msg.id) || (micApproved && pendingMicHost === msg.id)){
          endBroadcast(true);
          pendingJoinHost = null;
          pendingMicHost = null;
          joinApproved = false;
          micApproved = false;
        }
      }

    function handleJoinRequest(id, user){
      if(!broadcasting) return;
      showPopup(`@${user || 'user'} wants to join.`, [
        { label: 'Accept', onClick: () => { sendSignal({ type: 'approve-join', id }); startWatching(id); hidePopup(); } },
        { label: 'Deny', onClick: () => { sendSignal({ type: 'deny-join', id }); hidePopup(); } }
      ]);
    }

    function handleJoinApproved(){
      joinApproved = true;
      const stream = streams[pendingJoinHost];
      broadcastBtn.disabled = false;
      if(stream && !stream.started){
        startWatching(pendingJoinHost);
        stream.started = true;
      }
      startBroadcast();
      layoutMode = 'split';
      updateVideoLayout();
      // Keep pendingJoinHost so chat stays in host room
    }

    function handleJoinDenied(){
      joinApproved = false;
      const stream = streams[pendingJoinHost];
      pendingJoinHost = null;
      broadcastBtn.disabled = false;
      broadcastBtn.textContent = 'üé• Go Live';
      if(joinCamBtn) joinCamBtn.disabled = false;
      if(joinMicBtn) joinMicBtn.disabled = false;
      alert('Join request denied or busy.');
    }

    function handleMicRequest(id, user){
      if(!broadcasting) return;
      showPopup(`@${user || 'user'} wants to speak.`, [
        { label: 'Accept', onClick: () => { sendSignal({ type: 'approve-mic', id }); hidePopup(); } },
        { label: 'Deny', onClick: () => { sendSignal({ type: 'deny-mic', id }); hidePopup(); } }
      ]);
    }

    function handleMicApproved(){
      micApproved = true;
      const stream = streams[pendingMicHost];
      const hostVid = stream && stream.video.querySelector('video');
      if(hostVid){
        videoContainer.appendChild(hostVid);
      }
      layoutMode = 'split';
      updateVideoLayout();
      startBroadcast(null, true);
      // Clear pending mic host to ensure the broadcast persists
      pendingMicHost = null;
    }

    function handleMicDenied(){
      micApproved = false;
      const stream = streams[pendingMicHost];
      pendingMicHost = null;
      if(joinMicBtn) joinMicBtn.disabled = false;
      if(joinCamBtn) joinCamBtn.disabled = false;
      alert('Mic request denied.');
    }

    function handleGuestStart({ id, host }){
      guestMap[id] = host;
      const hostStream = streams[host];
      if(hostStream){
        hostStream.container.classList.add('open');
        if(!hostStream.started){
          startWatching(host);
          hostStream.started = true;
        }
        // Other viewers watch the guest separately so their video can be merged
        if(id !== clientId) startWatching(id);
      }
      if(!streams[id]){
        const u = userCache && userCache.find(u => (typeof u === 'string' ? u : u.id) === id);
        const name = typeof u === 'string' ? u : (u && u.name) || id;
        ensureStreamThumb(id, name, id === clientId);
      }
      if(streams[id]){
        streams[id].container.classList.add('open');
        streams[id].started = true;
      }
      const hostBox = hostStream && hostStream.video;
      const guestBox = streams[id] && streams[id].video;
      if(hostBox && guestBox){
        const aud = hostBox.querySelector(`audio[data-guest="${id}"]`);
        if(aud && !guestBox.querySelector('audio')) guestBox.appendChild(aud);
      }
      layoutMode = 'split';
      updateVideoLayout();
    }

    function handleInvite({ id, mode, user }) {
      const verb = mode === 'mic' ? 'join via mic' : 'join the broadcast';
      const msg = { id: `invite-${Date.now()}`, user: user || 'host', text: `invites you to ${verb}.` };
      const stream = streams[id];
      if (stream && stream.feed) {
        appendMessage(msg, false, stream.feed);
      } else {
        appendMessage(msg);
      }
      showPopup(`@${user || 'host'} invites you to ${verb}.`, [
        {
          label: 'Accept',
          onClick: () => {
            sendSignal({ type: mode === 'mic' ? 'mic-request' : 'join-request', id, user: store.user });
            hidePopup();
          }
        },
        { label: 'Deny', onClick: () => hidePopup() }
      ]);
    }

    function sendSignal(data){
      try { socket && socket.readyState === 1 && socket.send(JSON.stringify(data)); } catch {}
    }

      function receive(m, isLocal=false){
        if(!m || seen.has(m.id)) return;
        seen.add(m.id);
        if(activeRooms.size > 0 && !m.room) return;
        if(m.room){
          if(!streams[m.room]) ensureStreamThumb(m.room, m.room);
          if(streams[m.room]) appendMessage(m, false, streams[m.room].feed);
        } else {
          appendMessage(m);
          if(!isLocal) store.pushMsg(m);
        }
      }

      function renderHistory(){
      feed.innerHTML = '';
      const items = store.loadMsgs();
      items.slice().reverse().forEach(m => appendMessage(m, true));
      scrollToTop();
    }

      function appendMessage(m, skipScroll=false, container=feed){
        const mine = m.user === store.user;
        const li = document.createElement('li');
      li.className = 'msg' + (mine ? ' mine' : '');
      li.dataset.id = m.id;

      const av = document.createElement('div');
      av.className = 'avatar';
      if(m.profilePic){
        av.style.backgroundImage = `url(${m.profilePic})`;
        av.style.backgroundSize = 'cover';
        av.style.backgroundPosition = 'center';
      } else {
        av.textContent = initials(m.user);
      }
      av.style.cursor = 'pointer';
      av.addEventListener('click', () => {
        location.href = '/profile.html?user=' + encodeURIComponent(m.user);
      });

      const bubble = document.createElement('div');
      bubble.className = 'bubble' + (m.collapsed? ' collapsed' : '');

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `<span class="who">@${escapeHTML(m.user)}</span> ¬∑ <span>${fmtTime(m.ts)}</span>`;

      const text = document.createElement('div');
      text.className = 'msg-text';
      text.innerHTML = renderText(m.text || '', !!m.isAction);

      if(mine){
        const btn = document.createElement('button');
        btn.className = 'min-btn';
        btn.title = 'Minimize / expand';
        btn.setAttribute('aria-label','Minimize message');
        btn.textContent = m.collapsed? '‚§¢' : '‚§°';
        btn.addEventListener('click', () => {
          li.classList.toggle('collapsed');
          btn.textContent = li.classList.contains('collapsed') ? '‚§¢' : '‚§°';
        });
        bubble.appendChild(btn);
      }

        bubble.appendChild(meta);
      bubble.appendChild(text);
      const plain = text.textContent.trim();
      if(broadcasting && m.room === clientId && plain){
        const overlayText = `@${m.user}: ${plain}`;
        overlayMessages.push({ text: overlayText, ts: Date.now() });
        showOverlayMessage({ user: m.user, text: plain, profilePic: m.profilePic });
      }
      const fileData = m.file || m.image;
      if(fileData){
        const mime = m.fileType || ((fileData.match(/^data:(.*?);/) || [])[1] || '');
        const filename = m.fileName || m.name || '';
        const isModel = mime.includes('model') || /\.glb$/i.test(filename) || /\.gltf$/i.test(filename);
        if(mime.startsWith('video/')){
          const vid = document.createElement('video');
          vid.src = fileData;
          vid.controls = true;
          vid.playsInline = true;
          vid.setAttribute('playsinline','');
          vid.style.maxWidth = '100%';
          vid.style.borderRadius = '8px';
          attachCaptions(vid);
          if(m.image) vid.poster = m.image;
          bubble.appendChild(vid);
        } else if(mime.startsWith('audio/')){
          const aud = document.createElement('audio');
          aud.src = fileData;
          aud.controls = true;
          aud.style.width = '100%';
          bubble.appendChild(aud);
        } else if(isModel){
          const model = document.createElement('model-viewer');
          model.src = fileData;
          model.alt = filename || '3D model';
          model.style.width = '100%';
          model.style.height = '300px';
          model.style.borderRadius = '8px';
          model.setAttribute('camera-controls','');
          model.setAttribute('auto-rotate','');
          bubble.appendChild(model);
        } else if(mime.startsWith('image/')){
          const img = document.createElement('img');
          img.src = fileData;
          img.alt = filename || 'image';
          img.style.maxWidth = '100%';
          img.style.borderRadius = '8px';
          img.loading = 'lazy';
          bubble.appendChild(img);
        } else {
          const link = document.createElement('a');
          link.href = fileData;
          link.textContent = filename || 'download';
          link.download = filename || 'file';
          bubble.appendChild(link);
        }
      }

      if(container === feed){
        const actions = document.createElement('div');
        actions.className = 'actions';
        const likeBtn = document.createElement('button');
        likeBtn.className = 'like-btn';
        likeBtn.textContent = `‚ù§Ô∏è ${m.likes || 0}`;
        likeBtn.addEventListener('click', () => {
          try { if(socket && socket.readyState === 1) socket.send(JSON.stringify({ type:'like', messageId: m.id, user: store.user })); } catch {}
        });
        actions.appendChild(likeBtn);

        const commentsBox = document.createElement('div');
        commentsBox.className = 'comments';
        const commentsList = document.createElement('div');
        commentsList.className = 'comments-list';
        (m.comments || []).forEach(c => appendCommentElement(commentsList, c));
        const commentForm = document.createElement('form');
        commentForm.className = 'comment-form';
        const commentInput = document.createElement('input');
        commentInput.placeholder = 'Add comment...';
        commentForm.appendChild(commentInput);
        commentForm.addEventListener('submit', ev => {
          ev.preventDefault();
          const txt = commentInput.value.trim();
          if(!txt) return;
          try { if(socket && socket.readyState === 1) socket.send(JSON.stringify({ type:'comment', messageId: m.id, text: txt, user: store.user })); } catch {}
          commentInput.value = '';
        });
        commentsBox.appendChild(commentsList);
        commentsBox.appendChild(commentForm);

        bubble.appendChild(actions);
        bubble.appendChild(commentsBox);
      }

      if(mine){
        li.appendChild(bubble);
        li.appendChild(av);
      } else {
        li.appendChild(av);
        li.appendChild(bubble);
      }

      if(container === feed){
        container.insertBefore(li, container.firstChild);
        if(m.selfDestruct){
          const delay = Math.max(0, m.ts + m.selfDestruct - Date.now());
          setTimeout(() => {
            const el = feed.querySelector(`li[data-id="${m.id}"]`);
            if(el) el.remove();
            store.removeMsg(m.id);
          }, delay);
        }
        if(!skipScroll) scrollToTop();
      } else {
        container.appendChild(li);
        if(!skipScroll) container.scrollTop = container.scrollHeight;
      }
      }

      function appendCommentElement(list, c){
        const div = document.createElement('div');
        div.className = 'comment';
        div.innerHTML = `<span class="who">@${escapeHTML(c.user)}</span>: ${renderText(c.text)}`;
        list.appendChild(div);
      }

      function handleComment(c){
        if(!c || seenComments.has(c.id)) return;
        seenComments.add(c.id);
        const msgEl = feed.querySelector(`li[data-id="${c.messageId}"]`);
        const list = msgEl && msgEl.querySelector('.comments-list');
        if(list) appendCommentElement(list, c);
      }

      function handleLike(l){
        const msgEl = feed.querySelector(`li[data-id="${l.messageId}"]`);
        const btn = msgEl && msgEl.querySelector('.like-btn');
        if(btn) btn.textContent = `‚ù§Ô∏è ${l.count}`;
      }

      function handleCaption(c){
        const s = streams[c.id];
        if(!s || !s.captionTrack || !s.vid) return;
        const Cue = window.VTTCue || window.TextTrackCue;
        try{ s.captionTrack.addCue(new Cue(s.vid.currentTime, s.vid.currentTime+5, c.text)); }catch{}
      }

      function showPopup(message, actions){
        popupText.textContent = message;
        popupActions.innerHTML = '';
        actions.forEach(a => {
          const btn = document.createElement('button');
          btn.textContent = a.label;
          btn.addEventListener('click', () => {
            if(a.onClick) a.onClick();
          }, { once: true });
          popupActions.appendChild(btn);
        });
        popup.hidden = false;
      }

      function hidePopup(){ popup.hidden = true; }

      function systemNote(t){
        const div = document.createElement('div');
        div.className = 'system';
      div.textContent = t;
      feed.insertBefore(div, feed.firstChild);
      scrollToTop();
    }

    function scrollToTop(){
      feed.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function attachCaptions(vid){
      if(!vid) return;
      const tracks = [
        { src: 'static/captions/en.vtt', srclang: 'en', label: 'English', def: true },
        { src: 'static/captions/pt-en.vtt', srclang: 'pt', label: 'Portuguese/English' },
        { src: 'static/captions/ko.vtt', srclang: 'ko', label: 'Korean' },
        { src: 'static/captions/ar-en.vtt', srclang: 'ar', label: 'Arabic/English' }
      ];
      tracks.forEach(t => {
        const track = document.createElement('track');
        track.kind = 'captions';
        track.src = t.src;
        track.srclang = t.srclang;
        track.label = t.label;
        if(t.def) track.default = true;
        vid.appendChild(track);
      });
    }

    // --- Helpers ---
    function fmtTime(ts){
      const d = new Date(ts || Date.now());
      const h = d.getHours().toString().padStart(2,'0');
      const m = d.getMinutes().toString().padStart(2,'0');
      return `${h}:${m}`;
    }
    function initials(name){
      const parts = name.replace(/[^a-zA-Z0-9_\-.]/g,' ').trim().split(/\s+|[_.-]/).filter(Boolean);
      const a = (parts[0]||'?')[0]||'?';
      const b = (parts[1]||'')[0]||'';
      return (a + b).toUpperCase();
    }
    function escapeHTML(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }
    function linkify(s){
      const url = /((https?:\/\/)?[\w.-]+\.[a-z]{2,}(?:\/[\w%./#?=&-]*)?)/gi;
      return s.replace(url, (u) => {
        const href = /^(https?:)?\/\//i.test(u) ? u : 'https://' + u;
        return `<a href="${href}" target="_blank" rel="noopener">${escapeHTML(u)}</a>`;
      });
    }
    function renderText(s, isAction=false){
      const safe = escapeHTML(s);
      const withLinks = linkify(safe);
      return isAction ? `<em>${withLinks}</em>` : withLinks;
    }

    // Boot
    requireAuth();
  })();
  </script>
</body>
</html>
