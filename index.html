<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>CHAINeS Chat</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='48' fill='%2300e5a8'/%3E%3Ctext x='50' y='58' font-size='42' text-anchor='middle' fill='white' font-family='system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'%3EC%3C/text%3E%3C/svg%3E" />
  <meta name="color-scheme" content="dark light" />
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
      :root {
        --bg: #001a33;
        --panel: #00264d;
        --muted: #a0a0a0;
        --fg: #c0c0c0;
        --accent: #c0c0c0;
        --accent-2: #e0e0e0;
        --danger: #ff5d6e;
        --shadow: 0 0 10px rgba(192,192,192,.5);
        --radius: 16px;
        --lining: #c0c0c0;
      }
      :root[data-theme='light']{
        --bg:#1a1a1a;
        --panel:#2a2a2a;
        --fg:#ffd700;
        --muted:#c0a000;
        --accent:#ffd700;
        --accent-2:#ffd700;
        --shadow: 0 0 10px rgba(255,215,0,.5);
        --lining:#ffd700;
      }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin:0;
      background:
        radial-gradient(1200px 1200px at 20% -10%, color-mix(in oklab, var(--accent-2), transparent 85%), transparent 60%),
        radial-gradient(1000px 1000px at 120% 20%, color-mix(in oklab, var(--accent), transparent 88%), transparent 60%),
        var(--bg);
      color:var(--fg);
      font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .wrap { display:grid; grid-template-rows: auto 1fr auto; height:100vh; height:100dvh; width:100%; margin:0; }

    header { display:flex; align-items:center; gap:14px; padding:18px 18px; position: sticky; top: 0; z-index: 5; }
    .brand { display:flex; align-items:center; gap:10px; }
    .brand .logo { width:28px; height:28px; border-radius:8px; background: linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow: var(--shadow); }
    .brand h1 { font-weight: 800; letter-spacing:.4px; font-size: 18px; margin:0; }

    .status { margin-left:auto; display:flex; align-items:center; gap:10px; }
    .chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--lining);
            border-radius:999px; background: color-mix(in oklab, var(--panel), transparent 25%); box-shadow: var(--shadow); color: var(--fg); }
    #live-chip, #theme-toggle, #mode-toggle { cursor:pointer; }
    .dot { width:10px; height:10px; border-radius:999px; background:var(--muted); }
    .dot.ok { background: var(--accent); }
    .dot.local { background: #ffb020; }
    .dot.off { background: var(--danger); }
    .usr { font-weight:600; color: var(--fg); }

    main { display:flex; flex-direction:column; gap:0; padding:0; flex:1; }

    .feed { list-style:none; margin:0; padding:18px; border-radius: var(--radius); background: color-mix(in oklab, var(--panel), transparent 5%); overflow-y: auto; flex:1; box-shadow: var(--shadow); }
    .msg { display:flex; gap:10px; margin-bottom:14px; width:100%; }
    .msg.mine { flex-direction: row-reverse; }
    .avatar { width:36px; height:36px; border-radius:10px; display:grid; place-items:center; font-weight:700; background: #222a39; color:#c2d2ea; border:1px solid var(--lining); }
    .msg.mine .avatar { background: color-mix(in oklab, var(--accent), black 70%); color: var(--accent-2); }

    .bubble { flex:1; position:relative; padding:10px 12px 8px; border-radius: 12px; background: var(--panel); border:1px solid var(--lining); box-shadow: var(--shadow); }
    .msg.mine .bubble { background: color-mix(in oklab, var(--accent), var(--bg) 80%); border-color: var(--lining); }

    .meta { display:flex; align-items:center; gap:10px; margin-bottom:4px; font-size:12px; color: var(--muted); }
    .who { font-weight:700; color: var(--fg); }

    .msg.mine .meta { justify-content:flex-end; }
    .msg.mine .msg-text { text-align:right; }

    .msg-text { white-space: pre-wrap; word-wrap: break-word; }

    .actions { margin-top:6px; display:flex; gap:10px; }
    .like-btn { background:transparent; border:0; cursor:pointer; color:var(--fg); }
    .comments { margin-top:6px; }
    .comments-list { margin-bottom:6px; }
    .comment { font-size:13px; margin-bottom:4px; }
    .comment-form input { width:100%; padding:4px; border-radius:8px; border:1px solid var(--lining); background: var(--panel); color: var(--fg); }

    .msg.collapsed .msg-text { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; max-height: 3.3em; }
    .min-btn { position:absolute; top:8px; right:8px; border:0; background:transparent; color:var(--muted); cursor:pointer; font-size:16px; padding:2px 6px; border-radius:8px; }
    .min-btn:hover { color:var(--fg); background: rgba(255,255,255,.06); }

    .system { text-align:center; color: var(--muted); font-size: 13px; margin: 12px 0; }

    .composer { display:grid; grid-template-columns: 1fr auto auto; gap:10px; margin-bottom: 12px; }
    .input { display:flex; align-items:center; gap:10px; padding:10px 12px; border-radius: 12px; background: var(--panel); border:1px solid var(--lining); box-shadow: var(--shadow); }
    .input input { flex:1; font: inherit; color: var(--fg); background: transparent; border:0; outline:0; }
    .input input::placeholder { color: color-mix(in oklab, var(--muted), transparent 10%); }
    .send { padding:10px 14px; border-radius:12px; border:0; font-weight:700; cursor:pointer; color:#05130e; background: linear-gradient(180deg, var(--accent), var(--accent-2)); box-shadow: var(--shadow); }
    .send:disabled { opacity:.6; cursor:not-allowed; }

    /* Auth screen */
    .auth { position: fixed; inset:0; display:grid; place-items:center; background: linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.65)); backdrop-filter: blur(4px); }
    .card { width:min(520px, 92vw); padding:22px; border-radius: 18px; background: var(--panel); border: 1px solid var(--lining); box-shadow: var(--shadow); }
    .card h2 { margin:0 0 8px; font-size: 22px; }
    .card p { margin: 0 0 14px; color: var(--muted); }
    .fields { display:grid; gap:10px; }
    .fields input { width:100%; padding:12px 14px; border-radius:12px; border:1px solid var(--lining); background: var(--panel); color: var(--fg); font: inherit; }
    .actions { display:flex; gap:10px; margin-top:12px; }
    .btn { padding:12px 14px; border-radius:12px; border:0; font-weight:700; cursor:pointer; }
    .btn.primary { background: linear-gradient(180deg, var(--accent), var(--accent-2)); color:#05130e; }
    .btn.ghost { background: color-mix(in oklab, var(--panel), transparent 10%); color: var(--fg); border:1px solid var(--lining); }

    .muted-link { color: var(--muted); text-decoration: underline; cursor: pointer; }

    footer { padding: 8px 18px 16px; color: var(--muted); text-align:center; font-size: 12px; }
    a { color: var(--accent-2); }

    .users-panel { position:fixed; top:60px; right:20px; padding:14px; border-radius:var(--radius); background:var(--panel); border:1px solid var(--lining); box-shadow:var(--shadow); max-width:200px; max-height:60vh; overflow-y:auto; }
    .users-panel h3 { margin:0 0 8px; font-size:14px; }
    .users-panel ul { list-style:none; margin:0; padding:0; }
    .users-panel li { padding:4px 0; border-bottom:1px solid var(--lining); }
    .users-panel li:last-child { border-bottom:0; }

    .live-btn {
      margin-left:6px;
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 6px;
      border:1px solid var(--lining);
      border-radius:8px;
      background:color-mix(in oklab, var(--panel), transparent 10%);
      cursor:pointer;
      color:var(--fg);
      font-size:12px;
    }
    .live-dot {
      display:inline-block;
      width:8px;
      height:8px;
      margin-right:4px;
      border-radius:50%;
      background:var(--danger);
      animation: live-pulse 1s infinite;
    }
    @keyframes live-pulse {
      0%, 100% { opacity:1; }
      50% { opacity:0.2; }
    }

    #broadcast-btn.live {
      animation: live-pulse 1s infinite;
      border-color: var(--danger);
      color: var(--danger);
    }

    #streams { display:flex; flex-wrap:wrap; gap:10px; padding:10px; }
    .stream { position:relative; width:150px; border:1px solid var(--lining); border-radius:12px; padding:8px; background: var(--panel); cursor:pointer; }
    .stream.open { width:300px; }
    .stream .title { font-weight:700; margin-bottom:6px; }
    .stream .video { display:none; }
    .stream.open .video { display:block; }
    .stream .video video { width:100%; border-radius:8px; }
    .stream-feed { list-style:none; margin:8px 0 0; padding:0; max-height:120px; overflow-y:auto; display:none; }
    .stream.open .stream-feed { display:block; }
    .stream-composer { display:none; margin-top:4px; gap:4px; }
    .stream.open .stream-composer { display:flex; }
    .stream-composer input { flex:1; }
    #video-container { display:flex; flex-wrap:wrap; gap:10px; padding:10px; }
    #video-container video { max-width:240px; border-radius:12px; border:1px solid var(--lining); }

    /* ✅ make hidden actually hide, even with .auth display rules */
    [hidden] { display: none !important; }
    .auth.is-hidden { display: none !important; }
    @media (max-width: 600px) {
      header { flex-wrap: wrap; padding:12px; gap:8px; }
      .status { margin-left:0; flex-wrap:wrap; width:100%; gap:8px; }
      .status .chip { flex:1 1 auto; justify-content:center; }
      .feed { padding:12px; }
      .composer { margin:10px 10px 12px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <h1>CHAINeS Chat</h1>
      </div>
      <div class="status">
        <span class="chip" id="conn-chip" title="Connection status">
          <span class="dot off" id="conn-dot"></span>
          <span id="conn-label">Offline</span>
        </span>
        <span class="chip" id="live-chip" title="Users online">
          <span id="live-count">0</span> online
        </span>
        <button class="chip" id="broadcast-btn" title="Go live">🎥 Live</button>
        <button id="mode-toggle" class="chip" title="Switch between cloud or local modes"></button>
        <span class="chip" id="user-chip" title="Logged in user" style="display:none">
          <span class="usr" id="user-name"></span>
          <button id="logout-btn" class="btn ghost" style="padding:6px 10px" type="button">Logout</button>
        </span>
        <button id="theme-toggle" class="chip" title="Toggle dark or light mode"></button>
      </div>
    </header>

      <main>
        <div id="streams" class="streams"></div>
        <form id="composer" class="composer" autocomplete="off">
          <label class="input" for="text">
            <input id="text" name="text" placeholder="Type a message… (try /me waves or /clear)" />
          </label>
        <input id="file" type="file" accept="*/*" hidden />
        <button class="send" id="attach" type="button" title="Attach file" aria-label="Attach file">📎</button>
        <button class="send" id="send" type="submit">Send</button>
      </form>
        <div id="video-container" hidden></div>
        <ul id="feed" class="feed" aria-live="polite" aria-busy="false"></ul>
      </main>

    <footer>
      © <span id="year"></span> CHAINeS • Built for <a href="https://chaines.io" target="_blank" rel="noopener">chaines.io</a>
    </footer>
  </div>

  <div id="user-list" class="users-panel" hidden>
    <h3>Online now</h3>
    <ul id="users"></ul>
  </div>

  <!-- Auth overlay -->
  <section id="auth" class="auth" hidden>
    <div class="card">
      <h2>Welcome to CHAINeS Chat</h2>
      <p>Pick a username to join the chatroom.</p>
      <div class="fields">
        <input id="username" placeholder="Username (e.g., jodel)" maxlength="24" />
      </div>
      <div class="actions">
        <button class="btn primary" id="enter" type="button">Enter Chat</button>
        <button class="btn ghost" id="skip" type="button">Continue as Guest</button>
      </div>
      <p style="margin-top:10px">Optional backend socket: <span class="muted-link" id="ws-edit">configure</span></p>
      <div id="ws-config" class="fields" style="display:none; margin-top:8px">
        <input id="ws-url" placeholder="wss://chaines-io-chat.onrender.com/ws (optional)" />
        <button class="btn ghost" id="save-ws" type="button">Save Socket URL</button>
      </div>
    </div>
  </section>

  <script>
  ;(() => {
    const el = (q, parent=document) => parent.querySelector(q);
    const feed = el('#feed');
    const form = el('#composer');
    const input = el('#text');
    const attachBtn = el('#attach');
    const fileInput = el('#file');
    const defaultPlaceholder = input.placeholder;
    let pendingFile = null;
    const auth = el('#auth');
    const usernameInput = el('#username');
    const enterBtn = el('#enter');
    const skipBtn = el('#skip');
    const userChip = el('#user-chip');
    const userName = el('#user-name');
    const logoutBtn = el('#logout-btn');
    const connDot = el('#conn-dot');
    const connLabel = el('#conn-label');
    const connChip = el('#conn-chip');
    const liveCount = el('#live-count');
    const wsEdit = el('#ws-edit');
    const wsCfg = el('#ws-config');
    const wsUrlInput = el('#ws-url');
    const liveChip = el('#live-chip');
    const themeToggle = el('#theme-toggle');
    const modeToggle = el('#mode-toggle');
    const userList = el('#user-list');
    const usersEl = el('#users');
    const broadcastBtn = el('#broadcast-btn');
    const videoContainer = el('#video-container');
    const streamsEl = el('#streams');
    const streams = {};
    let pendingJoinHost = null;
    let joinApproved = false;

    el('#year').textContent = new Date().getFullYear();

    // --- Basic state ---
    const store = {
      get user() {
        try { return localStorage.getItem('chaines_username') || ''; }
        catch { return ''; }
      },
      set user(v) {
        try { v ? localStorage.setItem('chaines_username', v) : localStorage.removeItem('chaines_username'); }
        catch {}
      },
      get wsURL() {
        try { return localStorage.getItem('chaines_ws_url') || defaultWS(); }
        catch { return defaultWS(); }
      },
      set wsURL(v) {
        try { v ? localStorage.setItem('chaines_ws_url', v) : localStorage.removeItem('chaines_ws_url'); }
        catch {}
      },
      get theme() {
        try { return localStorage.getItem('chaines_theme') || ''; }
        catch { return ''; }
      },
      set theme(v) {
        try { v ? localStorage.setItem('chaines_theme', v) : localStorage.removeItem('chaines_theme'); }
        catch {}
      },
      pushMsg(m) {
        try {
          const items = JSON.parse(localStorage.getItem('chaines_messages') || '[]');
          items.push(m); while (items.length > 200) items.shift();
          localStorage.setItem('chaines_messages', JSON.stringify(items));
        } catch {}
      },
      loadMsgs() {
        try { return JSON.parse(localStorage.getItem('chaines_messages') || '[]'); } catch { return []; }
      },
      clearMsgs() {
        try { localStorage.removeItem('chaines_messages'); } catch {}
      }
    };

    function applyTheme(t){
      document.documentElement.dataset.theme = t;
      themeToggle.textContent = t === 'light' ? '🌙' : '☀️';
    }
    const initialTheme = store.theme || 'light';
    applyTheme(initialTheme);
    themeToggle.addEventListener('click', () => {
      const next = document.documentElement.dataset.theme === 'light' ? 'dark' : 'light';
      store.theme = next;
      applyTheme(next);
    });
    liveChip.addEventListener('click', () => { userList.hidden = !userList.hidden; });
    modeToggle.textContent = 'Go Cloud';
    modeToggle.addEventListener('click', () => {
      if (onlineMode === 'cloud') {
        try { socket && socket.close(); } catch {}
        socket = null;
        setStatus(bc ? 'local' : 'off');
      } else {
        connectWS();
      }
    });
    broadcastBtn.addEventListener('click', () => {
      if (broadcasting) { endBroadcast(); return; }
      const others = Object.keys(streams).filter(id => id !== clientId);
      if (others.length > 0 && !joinApproved) {
        const hostId = others[0];
        pendingJoinHost = hostId;
        sendSignal({ type: 'join-request', id: hostId, user: store.user });
        broadcastBtn.disabled = true;
        broadcastBtn.textContent = '⏳ Pending';
      } else {
        startBroadcast();
      }
    });
    window.addEventListener('beforeunload', () => {
      endBroadcast(true);
      for(const id in streams){
        if(streams[id].started && !streams[id].self){ endWatching(id); }
      }
    });

    // --- Connection setup (optional WebSocket + local BroadcastChannel fallback) ---
    let socket = null;
    let bc = null;
    let onlineMode = 'off'; // 'cloud' | 'local' | 'off'
    const seen = new Set();
    const seenComments = new Set();

    // --- WebRTC state ---
      const peerConnections = {};
      let localStream = null;
      let clientId = null;
    let broadcasting = false;
    let mediaRecorder = null;
    let recordedChunks = [];

      function updateUsers(list){
        liveCount.textContent = list.length;
        usersEl.innerHTML = '';
        const liveIds = new Set();
        list.forEach(u => {
          const li = document.createElement('li');
          const name = typeof u === 'string' ? u : u.name;
          if(u.live){
            const dot = document.createElement('span');
            dot.className = 'live-dot';
            li.appendChild(dot);
            liveIds.add(u.id);
            ensureStreamThumb(u.id, name, u.id === clientId);
          }
          li.appendChild(document.createTextNode('@' + name));
          usersEl.appendChild(li);
        });
        for(const id in streams){
          if(!liveIds.has(id)){
            streams[id].container.remove();
            delete streams[id];
          }
        }
      }

      function ensureStreamThumb(id, name, isSelf=false){
        if(streams[id]) return;
        const div = document.createElement('div');
        div.className = 'stream';
        div.innerHTML = `<div class="title">@${name} (<span class="listener-count">0</span>)</div><div class="video"></div><ul class="stream-feed"></ul><form class="stream-composer"><input type="text" placeholder="Comment" /><button type="submit">Send</button></form>`;
        const videoBox = div.querySelector('.video');
        const feed = div.querySelector('.stream-feed');
        const form = div.querySelector('.stream-composer');
        const input = form.querySelector('input');
        const count = div.querySelector('.listener-count');
        form.addEventListener('submit', ev => {
          ev.preventDefault();
          const text = input.value.trim();
          if(!text) return;
          postMessage({ text, room: id });
          input.value='';
        });
        div.addEventListener('click', e => {
          if(e.target.closest('form')) return;
          div.classList.toggle('open');
          if(div.classList.contains('open') && !streams[id].started && !isSelf){
            startWatching(id);
            streams[id].started = true;
          } else if(!div.classList.contains('open') && streams[id].started && !streams[id].self){
            endWatching(id);
            streams[id].started = false;
          }
        });
        streamsEl.appendChild(div);
        streams[id] = { container: div, video: videoBox, feed, input, count, self: isSelf, started:false };
      }

      // open stream bubble programmatically if needed
      function watchLive(id, name){
        ensureStreamThumb(id, name, id === clientId);
        streams[id].container.classList.add('open');
        if(!streams[id].started && !streams[id].self){
          startWatching(id);
          streams[id].started = true;
        }
      }

      function updateListenerCount(id, n){
        if(streams[id]) streams[id].count.textContent = n;
      }
    function sendJoin(){
      try { socket && socket.readyState === 1 && socket.send(JSON.stringify({ type:'join', user: store.user })); } catch {}
    }

    function defaultWS(){
      const host = (location.hostname && !/localhost|127\\.0\\.0\\.1/.test(location.hostname))
        ? 'chaines-io-chat.onrender.com'
        : location.host;
      const proto = location.protocol === 'https:' ? 'wss://' : 'ws://';
      return proto + host + '/ws';
    }

    function setStatus(mode){
      onlineMode = mode;
      connDot.classList.remove('ok','local','off');
      if(mode === 'cloud'){ connDot.classList.add('ok'); connLabel.textContent = 'Online (Cloud)'; }
      else if(mode === 'local'){ connDot.classList.add('local'); connLabel.textContent = 'Online (Local)'; updateUsers([]); }
      else { connDot.classList.add('off'); connLabel.textContent = 'Offline'; updateUsers([]); }
      modeToggle.textContent = mode === 'cloud' ? 'Go Local' : 'Go Cloud';
    }

    function connectWS(){
      const url = store.wsURL;
      if(!('WebSocket' in window)) return setStatus('off');
      try {
        socket = new WebSocket(url);
      } catch { setStatus('off'); return; }

      socket.addEventListener('open', () => { setStatus('cloud'); sendJoin(); });
      socket.addEventListener('close', () => { setStatus(bc? 'local' : 'off'); });
      socket.addEventListener('error', () => { setStatus(bc? 'local' : 'off'); });
      socket.addEventListener('message', ev => {
        try {
          const data = JSON.parse(ev.data);
          if(data && data.type === 'chat') receive(data);
          if(data && data.type === 'comment') handleComment(data);
          if(data && data.type === 'like') handleLike(data);
          if(data && data.type === 'system') systemNote(data.text);
          if(data && data.type === 'users') updateUsers(data.users || []);
          if(data && data.type === 'count') liveCount.textContent = data.count;
          if(data && data.type === 'history') {
            store.clearMsgs();
            feed.innerHTML = '';
            (data.messages || []).forEach(m => receive(m));
          }
          if(data && data.type === 'id') clientId = data.id;
          if(data && data.type === 'listeners') updateListenerCount(data.id, data.count);
          if(data && data.type === 'watcher') handleWatcher(data.id);
          if(data && data.type === 'offer') handleOffer(data);
          if(data && data.type === 'answer') handleAnswer(data);
          if(data && data.type === 'candidate') handleCandidate(data);
          if(data && data.type === 'bye') handleBye(data);
          if(data && data.type === 'join-request') handleJoinRequest(data.id, data.user);
          if(data && data.type === 'join-approved') handleJoinApproved();
          if(data && data.type === 'join-denied') handleJoinDenied();
        } catch {}
      });
    }

    function setupLocal(){
      if(!('BroadcastChannel' in window)) { setStatus('off'); return; }
      bc = new BroadcastChannel('chaines_chat');
      bc.onmessage = (ev) => {
        const m = ev.data; if(m && m.type === 'chat') receive(m);
      };
      if(onlineMode !== 'cloud') setStatus('local');
    }

    // --- Auth flow ---
    function requireAuth(){
      if (store.user) {
        enterChat(store.user);
      } else {
        auth.hidden = false;
        auth.classList.remove('is-hidden');
        auth.style.display = 'grid';
        setTimeout(() => usernameInput && usernameInput.focus(), 50);
      }
    }

    function enterChat(name){
      const cleaned = (name || '').replace(/[^a-zA-Z0-9_\-.]/g,'').slice(0,24);
      store.user = cleaned || ('guest-' + Math.floor(Math.random()*9999));
      userName.textContent = '@' + store.user;
      userChip.style.display = 'inline-flex';

      // decisively hide overlay
      auth.classList.add('is-hidden');
      auth.setAttribute('hidden','');
      auth.style.display = 'none';

      renderHistory();
      if (!socket || socket.readyState > 1) connectWS();
      else sendJoin();
      if (!bc) setupLocal();
      input && input.focus();
      systemNote(`You are signed in as @${store.user}.`);
    }

    enterBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const v = (usernameInput.value || '').replace(/[^a-zA-Z0-9_\-.]/g,'').slice(0,24);
      enterChat(v);
    });

    skipBtn.addEventListener('click', (e) => {
      e.preventDefault();
      enterChat('guest-' + Math.floor(Math.random()*9999));
    });

    // Enter key on username field
    usernameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); enterBtn.click(); }
    });

    logoutBtn.addEventListener('click', (e) => { e.preventDefault(); store.user=''; location.reload(); });

    wsEdit.addEventListener('click', () => {
      wsCfg.style.display = wsCfg.style.display==='none' ? 'grid' : 'none';
      wsUrlInput.value = store.wsURL;
    });
    el('#save-ws').addEventListener('click', (e) => {
      e.preventDefault();
      store.wsURL = wsUrlInput.value.trim();
      alert('Saved WebSocket URL.');
    });

    // --- Messaging ---
    form.addEventListener('submit', ev => {
      ev.preventDefault();
      const raw = (input.value || '').trim();
      if(!raw && !pendingFile) return;

      if(raw){
        // Commands
        if(raw === '/clear'){ store.clearMsgs(); feed.innerHTML=''; input.value=''; input.placeholder = defaultPlaceholder; pendingFile=null; systemNote('Cleared local chat history.'); return; }
        if(/^\s*\/me\s+/.test(raw)){
          const act = raw.replace(/^\s*\/me\s+/, '');
          postMessage({ text: `*${act}*`, isAction:true });
          input.value='';
          input.placeholder = defaultPlaceholder;
          pendingFile = null;
          return;
        }
      }

      const msg = { text: raw };
      if(pendingFile){
        msg.file = pendingFile.dataUrl;
        msg.fileName = pendingFile.name;
        msg.fileType = pendingFile.type;
        if(pendingFile.type.startsWith('image/')){
          msg.image = pendingFile.dataUrl;
          msg.name = pendingFile.name;
        }
      }
      postMessage(msg);
      input.value = '';
      input.placeholder = defaultPlaceholder;
      pendingFile = null;
    });

    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        pendingFile = { dataUrl: reader.result, name: file.name, type: file.type };
        input.placeholder = `Comment on ${file.name}`;
        input.focus();
      };
      reader.readAsDataURL(file);
      fileInput.value = '';
    });

      function postMessage({ text='', image, file, fileName, fileType, name, isAction=false, broadcast=false, video, room }){
      if(broadcast && joinApproved && pendingJoinHost){
        room = pendingJoinHost;
      }
      const msg = {
        id: Date.now().toString(36) + Math.random().toString(36).slice(2,7),
        type: 'chat',
        user: store.user,
          text: text,
          room: room,
        image: image,
        file: file,
        fileName: fileName || name,
        fileType: fileType,
        name: fileName || name,
        isAction,
        broadcast,
        video,
        ts: Date.now(),
        likes: 0,
        comments: []
      };

      // Push to UI + storage immediately
        receive(msg, true);
        if(!room) store.pushMsg(msg);

      // Broadcast locally
      try { bc && bc.postMessage(msg); } catch {}

      // Send to server if available
        try { if(socket && socket.readyState === 1) socket.send(JSON.stringify(msg)); } catch {}
      }

    // --- WebRTC helpers ---
    function startBroadcast(){
      if(broadcasting) return;
      navigator.mediaDevices.getUserMedia({ video:true, audio:true }).then(stream => {
        localStream = stream;
        recordedChunks = [];
        try {
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = e => { if(e.data.size) recordedChunks.push(e.data); };
          mediaRecorder.start();
        } catch {}
        broadcasting = true;
        broadcastBtn.textContent = '⏹ End';
        broadcastBtn.title = 'End live broadcast';
        broadcastBtn.classList.add('live');
        videoContainer.removeAttribute('hidden');
        const vid = document.createElement('video');
        vid.srcObject = stream;
        vid.muted = true;
        vid.autoplay = true;
        vid.playsInline = true;
        videoContainer.appendChild(vid);
        sendSignal({ type: 'broadcaster' });
      }).catch(() => alert('Unable to access camera/microphone'));
    }

    function endBroadcast(forced=false){
      if(!broadcasting) return;
      broadcasting = false;
      joinApproved = false;
      broadcastBtn.disabled = false;
      broadcastBtn.textContent = '🎥 Live';
      broadcastBtn.title = 'Go live';
      broadcastBtn.classList.remove('live');
      const note = forced ? new Date().toLocaleString() :
        (prompt('Broadcast end comment?') || '').trim();
      const hadRecorder = !!mediaRecorder;
      if(mediaRecorder){
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const reader = new FileReader();
          reader.onloadend = () => {
            const dataUrl = reader.result;
            postMessage({
              text: `⏹ Broadcast ended${note ? ': '+note : ''}`,
              video: dataUrl,
              file: dataUrl,
              fileName: `broadcast-${Date.now()}.webm`,
              fileType: 'video/webm',
              broadcast: true
            });
          };
          reader.readAsDataURL(blob);
        };
        try { mediaRecorder.stop(); } catch {}
        mediaRecorder = null;
      }
      if(localStream){
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      for(const id in peerConnections){
        try{ peerConnections[id].close(); }catch{}
        delete peerConnections[id];
      }
      sendSignal({ type: 'end-broadcast' });
      videoContainer.innerHTML = '';
      videoContainer.setAttribute('hidden','');
      if(!hadRecorder){
        postMessage({ text: `⏹ Broadcast ended${note ? ': '+note : ''}`, broadcast: true });
      }
    }

      function startWatching(id){
        sendSignal({ type: 'watcher', id });
      }

      function endWatching(id){
        sendSignal({ type: 'unwatcher', id });
      }

    function handleWatcher(id){
      const pc = new RTCPeerConnection();
      peerConnections[id] = pc;
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      pc.onicecandidate = e => { if(e.candidate) sendSignal({ type:'candidate', id, candidate: e.candidate }); };
      pc.createOffer().then(o => pc.setLocalDescription(o)).then(() => {
        sendSignal({ type:'offer', id, sdp: pc.localDescription });
      });
    }

      function handleOffer(msg){
        const pc = new RTCPeerConnection();
        peerConnections[msg.id] = pc;
        pc.ontrack = ev => {
          const vid = document.createElement('video');
          vid.srcObject = ev.streams[0];
          vid.autoplay = true;
          vid.playsInline = true;
          const box = streams[msg.id] && streams[msg.id].video;
          if(box) box.appendChild(vid);
          pc._video = vid;
        };
        pc.onicecandidate = e => { if(e.candidate) sendSignal({ type:'candidate', id: msg.id, candidate: e.candidate }); };
        pc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
          .then(() => pc.createAnswer())
          .then(ans => pc.setLocalDescription(ans))
          .then(() => { sendSignal({ type:'answer', id: msg.id, sdp: pc.localDescription }); });
      }

    function handleAnswer(msg){
      const pc = peerConnections[msg.id];
      if(pc) pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    }

    function handleCandidate(msg){
      const pc = peerConnections[msg.id];
      if(pc && msg.candidate) pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
    }

      function handleBye(msg){
        const pc = peerConnections[msg.id];
        if(pc){
          if(pc._video) pc._video.remove();
          pc.close();
          delete peerConnections[msg.id];
        }
        if(streams[msg.id]){
          streams[msg.id].started = false;
          streams[msg.id].video.innerHTML = '';
          streams[msg.id].container.classList.remove('open');
        }
        if(joinApproved && pendingJoinHost === msg.id){
          endBroadcast(true);
          pendingJoinHost = null;
        }
      }

    function handleJoinRequest(id, user){
      const ok = confirm(`Allow @${user || 'user'} to join?`);
      sendSignal({ type: ok ? 'approve-join' : 'deny-join', id });
    }

    function handleJoinApproved(){
      joinApproved = true;
      broadcastBtn.disabled = false;
      startBroadcast();
    }

    function handleJoinDenied(){
      joinApproved = false;
      pendingJoinHost = null;
      broadcastBtn.disabled = false;
      broadcastBtn.textContent = '🎥 Live';
      alert('Join request denied or busy.');
    }

    function sendSignal(data){
      try { socket && socket.readyState === 1 && socket.send(JSON.stringify(data)); } catch {}
    }

      function receive(m, isLocal=false){
        if(!m || seen.has(m.id)) return;
        seen.add(m.id);
        if(m.room){
          if(!streams[m.room]) ensureStreamThumb(m.room, m.room);
          if(streams[m.room]) appendStreamMessage(streams[m.room], m);
        } else {
          appendMessage(m);
          if(!isLocal) store.pushMsg(m);
        }
      }

      function renderHistory(){
      feed.innerHTML = '';
      const items = store.loadMsgs();
      items.slice().reverse().forEach(m => appendMessage(m, true));
      scrollToTop();
    }

      function appendMessage(m, skipScroll=false){
        const mine = m.user === store.user;
        const li = document.createElement('li');
      li.className = 'msg' + (mine ? ' mine' : '');
      li.dataset.id = m.id;

      const av = document.createElement('div');
      av.className = 'avatar';
      av.textContent = initials(m.user);

      const bubble = document.createElement('div');
      bubble.className = 'bubble' + (m.collapsed? ' collapsed' : '');

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `<span class="who">@${escapeHTML(m.user)}</span> · <span>${fmtTime(m.ts)}</span>`;

      const text = document.createElement('div');
      text.className = 'msg-text';
      text.innerHTML = renderText(m.text || '', !!m.isAction);

      if(mine){
        const btn = document.createElement('button');
        btn.className = 'min-btn';
        btn.title = 'Minimize / expand';
        btn.setAttribute('aria-label','Minimize message');
        btn.textContent = m.collapsed? '⤢' : '⤡';
        btn.addEventListener('click', () => {
          li.classList.toggle('collapsed');
          btn.textContent = li.classList.contains('collapsed') ? '⤢' : '⤡';
        });
        bubble.appendChild(btn);
      }

        bubble.appendChild(meta);
      bubble.appendChild(text);
      const fileData = m.file || m.image;
      if(fileData){
        const mime = m.fileType || ((fileData.match(/^data:(.*?);/) || [])[1] || '');
        const filename = m.fileName || m.name || '';
        const isModel = mime.includes('model') || /\.glb$/i.test(filename) || /\.gltf$/i.test(filename);
        if(mime.startsWith('video/')){
          const vid = document.createElement('video');
          vid.src = fileData;
          vid.controls = true;
          vid.style.maxWidth = '100%';
          vid.style.borderRadius = '8px';
          bubble.appendChild(vid);
        } else if(mime.startsWith('audio/')){
          const aud = document.createElement('audio');
          aud.src = fileData;
          aud.controls = true;
          aud.style.width = '100%';
          bubble.appendChild(aud);
        } else if(isModel){
          const model = document.createElement('model-viewer');
          model.src = fileData;
          model.alt = filename || '3D model';
          model.style.width = '100%';
          model.style.height = '300px';
          model.style.borderRadius = '8px';
          model.setAttribute('camera-controls','');
          model.setAttribute('auto-rotate','');
          bubble.appendChild(model);
        } else if(mime.startsWith('image/')){
          const img = document.createElement('img');
          img.src = fileData;
          img.alt = filename || 'image';
          img.style.maxWidth = '100%';
          img.style.borderRadius = '8px';
          img.loading = 'lazy';
          bubble.appendChild(img);
        } else {
          const link = document.createElement('a');
          link.href = fileData;
          link.textContent = filename || 'download';
          link.download = filename || 'file';
          bubble.appendChild(link);
        }
      }

      const actions = document.createElement('div');
      actions.className = 'actions';
      const likeBtn = document.createElement('button');
      likeBtn.className = 'like-btn';
      likeBtn.textContent = `❤️ ${m.likes || 0}`;
      likeBtn.addEventListener('click', () => {
        try { if(socket && socket.readyState === 1) socket.send(JSON.stringify({ type:'like', messageId: m.id, user: store.user })); } catch {}
      });
      actions.appendChild(likeBtn);

      const commentsBox = document.createElement('div');
      commentsBox.className = 'comments';
      const commentsList = document.createElement('div');
      commentsList.className = 'comments-list';
      (m.comments || []).forEach(c => appendCommentElement(commentsList, c));
      const commentForm = document.createElement('form');
      commentForm.className = 'comment-form';
      const commentInput = document.createElement('input');
      commentInput.placeholder = 'Add comment...';
      commentForm.appendChild(commentInput);
      commentForm.addEventListener('submit', ev => {
        ev.preventDefault();
        const txt = commentInput.value.trim();
        if(!txt) return;
        try { if(socket && socket.readyState === 1) socket.send(JSON.stringify({ type:'comment', messageId: m.id, text: txt, user: store.user })); } catch {}
        commentInput.value = '';
      });
      commentsBox.appendChild(commentsList);
      commentsBox.appendChild(commentForm);

      bubble.appendChild(actions);
      bubble.appendChild(commentsBox);

      if(mine){
        li.appendChild(bubble);
        li.appendChild(av);
      } else {
        li.appendChild(av);
        li.appendChild(bubble);
      }

        feed.insertBefore(li, feed.firstChild);
        if(!skipScroll) scrollToTop();
      }

      function appendStreamMessage(stream, m){
        const li = document.createElement('li');
        li.textContent = `@${m.user}: ${m.text}`;
        stream.feed.appendChild(li);
        stream.feed.scrollTop = stream.feed.scrollHeight;
      }

      function appendCommentElement(list, c){
        const div = document.createElement('div');
        div.className = 'comment';
        div.innerHTML = `<span class="who">@${escapeHTML(c.user)}</span>: ${renderText(c.text)}`;
        list.appendChild(div);
      }

      function handleComment(c){
        if(!c || seenComments.has(c.id)) return;
        seenComments.add(c.id);
        const msgEl = feed.querySelector(`li[data-id="${c.messageId}"]`);
        const list = msgEl && msgEl.querySelector('.comments-list');
        if(list) appendCommentElement(list, c);
      }

      function handleLike(l){
        const msgEl = feed.querySelector(`li[data-id="${l.messageId}"]`);
        const btn = msgEl && msgEl.querySelector('.like-btn');
        if(btn) btn.textContent = `❤️ ${l.count}`;
      }

      function systemNote(t){
        const div = document.createElement('div');
        div.className = 'system';
      div.textContent = t;
      feed.insertBefore(div, feed.firstChild);
      scrollToTop();
    }

    function scrollToTop(){
      feed.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // --- Helpers ---
    function fmtTime(ts){
      const d = new Date(ts || Date.now());
      const h = d.getHours().toString().padStart(2,'0');
      const m = d.getMinutes().toString().padStart(2,'0');
      return `${h}:${m}`;
    }
    function initials(name){
      const parts = name.replace(/[^a-zA-Z0-9_\-.]/g,' ').trim().split(/\s+|[_.-]/).filter(Boolean);
      const a = (parts[0]||'?')[0]||'?';
      const b = (parts[1]||'')[0]||'';
      return (a + b).toUpperCase();
    }
    function escapeHTML(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }
    function linkify(s){
      const url = /((https?:\/\/)?[\w.-]+\.[a-z]{2,}(?:\/[\w%./#?=&-]*)?)/gi;
      return s.replace(url, (u) => {
        const href = /^(https?:)?\/\//i.test(u) ? u : 'https://' + u;
        return `<a href="${href}" target="_blank" rel="noopener">${escapeHTML(u)}</a>`;
      });
    }
    function renderText(s, isAction=false){
      const safe = escapeHTML(s);
      const withLinks = linkify(safe);
      return isAction ? `<em>${withLinks}</em>` : withLinks;
    }

    // Boot
    requireAuth();
  })();
  </script>
</body>
</html>
